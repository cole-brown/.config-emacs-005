[[file:source/user/template.el::;;; user/config/TODO-FILENAME.el --- TODO-SHORT-DESCRIPTION -*- lexical-binding: t; -*-][template.el]]
GOTO [[here][U R HERE]]

* ├DONE───┤ .emacs.d layout
CLOSED: [2025-06-03 Tue 22:33]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

source/user/config
  - dev-env?
  - devops?
  - languages
  - keybinds?
  - org

** old


├── core
│   ├── boot
│   │   ├── 00-early
│   │   ├── 10-init
│   │   ├── 20-config
│   │   └── 99-finalize
│   └── modules
│       ├── elisp
│       │   ├── datetime
│       │   ├── jerky
│       │   │   └── test
│       │   └── utils
│       ├── emacs
│       │   ├── alist
│       │   │   ├── test
│       │   │   │   └── type
│       │   │   └── type
│       │   ├── buffer
│       │   ├── chrome
│       │   ├── dlv
│       │   │   └── test
│       │   ├── imp
│       │   │   └── test
│       │   │       └── loading
│       │   ├── innit
│       │   ├── path
│       │   ├── str
│       │   └── template
│       ├── output
│       │   └── nub
│       │       └── test
│       └── system
│           ├── multiplexer
│           └── secret
├── mantle
│   ├── config
│   │   ├── dev-env
│   │   │   └── languages
│   │   ├── hydra
│   │   ├── keybinds
│   │   └── org
│   ├── init
│   │   └── keybinds
│   │       └── general
│   └── theme
│       └── zenburn
├── modules
│   ├── dev-env
│   │   └── taskspace
│   ├── emacs
│   │   ├── persp+
│   │   └── perspective
│   ├── input
│   ├── mode
│   │   └── org
│   └── tools
│       └── signature


** snippets

├── snippets
│   ├── emacs-lisp-mode
│   ├── fundamental-mode
│   ├── gitconfig-mode
│   ├── org-mode
│   ├── prog-mode
│   ├── python-mode
│   ├── sh-mode
│   └── yaml-mode

* ├DONE───┤ imp
CLOSED: [2025-06-03 Tue 22:33]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

** refactor symbol names

get
  - [X] copy paste imp to this .emacs

init.el [[file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/init.el]]

first
  - [-] rename functions
    - [X] int<imp> -> imp--
    - [ ] : -> /

ChatGPT?
  - process-file already exists... oops.

#+begin_src elisp
  (require 'cl-lib)

  ;; imp:provide:with-emacs
  ;; imp:path:root/set
  ;; int<imp>:load:parse
  ;;
  ;; ...oh wait test functions...
  ;; ...those ones got wild...
  ;; test<imp/load>::helper::int<imp>:load:parse
  (defun _refactor-buffer-00 (namespace)
    "[DONE] more normal func/var names."
    (let* ((regex (rx-to-string
                   `(and
                     (or
                      (and "int<"
                           ,namespace
                           ">")
                      ,namespace)
                     ":"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))

      (goto-char (point-min))

      (while (re-search-forward regex nil t)
        (replace-match (concat namespace
                               (if (string-prefix-p "int<" (match-string 0))
                                   "--" ; private
                                 "/") ; public
                               (replace-regexp-in-string "[/:]" "-" (match-string 1)))))))

  (defun _refactor-buffer-01 (namespace)
    "[DONE] even normaler func/var names"
    (let* ((regex (rx-to-string
                   `(and
                     (group
                      (not "/")
                      ,namespace)
                     "/"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))

      (goto-char (point-min))

      (while (re-search-forward regex nil t)
        (replace-match (concat (match-string 1)
                               "-"
                               (match-string 2))))))
  ;; (_refactor-shit "imp" "source/core/packages/imp/error.el")

  (defun _refactor-file (namespace file)
    "Process a single FILE for NAMESPACE refactoring."
    (let* ((existing-buffer (find-buffer-visiting file))
           (regex (rx-to-string
                   `(and
                     (or
                      (and "int<"
                           ,namespace
                           ">")
                      ,namespace)
                     ":"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))
      (save-window-excursion
        (save-mark-and-excursion
          (if existing-buffer
              (switch-to-buffer existing-buffer)
            (find-file file))
          (goto-char (point-min))

          ;;(_refactor-buffer-00 namespace)
          (_refactor-buffer-01 namespace)

          (save-buffer)
          (unless existing-buffer
            (kill-buffer))))))

  (defun _refactor-directory (namespace dir)
    "Process all *.el files in DIR recursively for refactoring."
    (dolist (file (directory-files-recursively dir "\\.el$"))
      (_refactor-file namespace file)))

  (defun _refactor-shit (namespace path)
    "Prompt the user for a PATH and refactor namespace patterns within it."
    (interactive "GPath to file or directory: ")
    (if (not (file-exists-p path))
        (error "The path does not exist!")
      (if (file-directory-p path)
          (_refactor-directory namespace path)
        (_refactor-file namespace path))))

  ;; [FILE]  (_refactor-shit "imp" "source/core/packages/imp/init.el")
  ;; [ALL] (_refactor-shit "imp" "source/core/packages/imp")
  ;;
  ;; [TODO] (_refactor-shit "imp" "source/core/packages/imp/error.el")
#+end_src

debug...
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k

test on:
  - [X] ~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/init.el

run on:
  - [X] ~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp

save script off somewhere for the next thing...
  - [X] [[file:scripts/refactor-sn4-to-sn5.el]]

** imp/provide/with-emacs

Make ~imp/provide~ act like ~imp/provide/with-emacs~ by default.
  - flag param to not ~with-emacs~ it.

DONE

** go through files in order

and do what?

check for includes and non-halal shit

files:
  - [X] error.el
  - [X] debug.el
  - [X] alist.el
    - feature uses this, so shouldn't it be before it?
      - Let's find out...
  - [X] tree.el
    - feature uses this, so shouldn't it be before it?
      - Let's find out...
  - [X] feature.el
  - [X] path.el
  - [X] flag.el
  - [X] timing.el
  - [X] provide
  - [X] load
  - [X] require
  - [X] package
  - [X] commands

** load a file

(imp-load :feature '(:test)
          :filename "test.el"
          :optional t)

see [[file:init.el::;; (setq imp--debugging? t)][here]] for trying to get imp load working

Debugger entered--Lisp error: (error "[ERROR     ]: imp-load: Feature is still not defined after loading the file!\n  feature:       (:quote test)\n  path:          \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/test.el\"\n  ‘load’-result: t")

Am I going round in circles?
Seen this about 3 times?

Debugger entered--Lisp error: (error "[ERROR-----]: imp--tree-contains: CHAIN is not a chain: :test")
  signal(error ("[ERROR-----]: imp--tree-contains: CHAIN is not a chain: :test"))
  error("[ERROR-----]: imp--tree-contains: CHAIN is not a chain: %S" :test)
  apply(error "[ERROR-----]: imp--tree-contains: CHAIN is not a chain: %S" :test)
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  ...
  imp--tree-contains?(:test ((:test) (:imp (require) (load) (provide))))
  (null (imp--tree-contains? (imp-feature-normalize features) imp-features))
  (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features)))
  (progn (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features))))
  (if imp-features (progn (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features)))))
  imp-feature-exists?(((:test)))
  (or (imp-feature-exists? feature) (featurep (imp-feature-normalize-for-emacs feature)))
  imp-provided?((:test))

(imp-feature-normalize '((:test)))

(imp--tree-contains? (imp--feature-normalize '((:test))) imp-features)

ok. it was
this:    (imp-feature-normalize :test)
vs this: (imp--feature-normalize :test)


;; (setq imp--debugging? t)
;; (imp-load :feature '(:test) :path "source/user" :filename "test.el")
;; imp-features
;; features
;; (imp-provided? :test)
;; (imp--unprovide-from-emacs :test)

test.el load work!

** unprovide

(setq imp--tree-debug-flag t)

not fully tested but here we be.

DONE

** again, check for unused funcs and shit

test.el: do the refactoring; missed this file
  - [ ] k
    - Meh

search for what to get all?
rg '^\(def(un|var|const|custom) ' .
rg '^\(def[a-z]* ' .


TODO
TODO
TODO
TODO
TODO
Check [9/17]
  - [X] source/core/packages/imp/init.el
    - [X] 61   (defgroup imp nil

  - [X] source/core/packages/imp/fundamental.el
    - [X] 34   (defun imp--string-or-nil (whatever)
    - [X] 44   (defun imp--string-empty? (str &optional trim?)
    - [X] 63   (defun imp--unquote (arg)

  - [X] source/core/packages/imp/output.el
    - [X] 30   (defcustom imp-output-buffer "ⓘ-imp-output-ⓘ"
    - [X] 36   (defcustom imp-output-level
    - [X] 61   (defun imp--output-callers (callers)
    - [X] 90   (defun imp--output-level-get (level setting)
    - [X] 98   (defun imp--output-prefix (level)
    - [X] 131  (defun imp--output-sink (message &rest args)
    - [X] 150  (defun imp--output (level caller string args)

  - [X] source/core/packages/imp/error.el
    - [X] 30   (defun imp--error (caller string &rest args)
    - [X] 51   (defun imp--error-if (error? caller string &rest args)
    - [X] 71   (defun imp--error-user (caller string &rest args)
      - [X] Delete.

  - [X] source/core/packages/imp/debug.el
    - [X] 40   (defvar imp--debugging? nil
    - [X] 44   (defun imp-debug (enabled?)
      - [X] delete
    - [X] 52   (defun imp-debug-toggle ()
    - [X] 61   (defun imp-debug-status (&optional msg)
    - [X] 105  (defun imp--debug (caller string &rest args)
    - [X] 122  (defun imp--debug-newline ()
    - [X] 136  (defun imp--debug-init ()

  - [X] source/core/packages/imp/alist.el
    - [X] 26   (defun imp--list-flatten (input)
    - [X] 55   (defun imp--alist-key-valid (caller key &optional error?)
    - [X] 73   (defun imp--alist-get-value (key alist &optional equal-fn)
    - [X] 83   (defun imp--alist-get-pair (key alist &optional equal-fn)
    - [X] 92   (defun imp--alist-update-helper (key value alist &optional equal-fn)
    - [X] 118  (defmacro imp--alist-update (key value alist &optional equal-fn)
    - [X] 147  (defun imp--alist-delete-helper (key alist &optional equal-fn)
    - [X] 164  (defmacro imp--alist-delete (key alist &optional equal-fn)

  - [X] source/core/packages/imp/tree.el
    - [X] 31   (defvar imp--tree-debug-flag nil
    - [X] 35   (defun imp--tree-debug (caller string &rest args)
    - [X] 48   (defun imp--tree-node? (node)
    - [X] 68   (defun imp--tree-tree? (tree)
    - [X] 97   (defun imp--tree-chain? (chain &optional rooted)
    - [X] 131  (defun imp--tree-key-exists? (key tree)
    - [X] 143  (defun imp--tree-chain (chain value)
    - [X] 182  (defun imp--tree-create (chain value)
    - [X] 188  (defun imp--tree-branch-update (entry branch)
    - [X] 221  (defun imp--tree-update-helper (chain value tree)
    - [X] 362  (defmacro imp--tree-update (chain value tree)
    - [X] 390  (defun imp--tree-contains? (chain tree)
    - [X] 436  (defun imp--tree-delete-helper (chain tree)
    - [X] 539  (defmacro imp--tree-delete (chain tree)
    - [X] 593  (defun imp--tree-map (function chain-reversed tree &optional dbg-depth)
    - [X] 675  (defun imp--tree-chains-get-all (chain-reversed tree)

  - [X] source/core/packages/imp/feature.el
    - [X] 36   (defvar imp-features nil
    - [X] 79   (defvar imp-features-locate nil
    - [X] 95   (defconst imp--features-locate-equal #'equal
    - [X] 106  (defun imp-feature-exists? (features)
    - [X] 117  (defun imp-feature? (&rest feature)
    - [X] 126  (defun imp-mode? (mode)
    - [X] 136  (defun imp--feature-count (&optional tree)
    - [X] 152  (defun imp-feature-count ()
    - [X] 164  (defconst imp--feature-replace-rx
    - [X] 190  (defconst imp--feature-replace-separator
    - [X] 198  (defun imp--feature-normalize-name (name)
    - [X] 220  (defun imp--feature-normalize-chain (&rest chain)
    - [X] 255  (defun imp--feature-normalize-to-list (&rest chain)
    - [X] 300  (defun imp-feature-normalize-for-emacs (&rest feature)
    - [X] 324  (defun imp-feature-normalize-for-imp (&rest input)
    - [X] 360  (defun imp-feature-normalize-for-display (&rest feature)
    - [X] 385  (defun imp--feature-add (normalized)
    - [X] 412  (defun imp--feature-get-tree (normalized)
    - [X] 417  (defun imp--feature-delete (normalized)
    - [X] 426  (defun imp-feature-assert (&rest feature)
    - [X] 446  (defun imp--feature-locations (feature-root)
    - [X] 452  (defun imp--feature-paths (&rest feature)
    - [X] 526  (defun imp-feature-at (feature-root feature-alist)

  - [X] source/core/packages/imp/path.el
    - [X] 39   (defconst imp--path-replace-rx
    - [X] 165  (defvar imp-path-roots nil
    - [X] 174  (defconst imp-path-filename-init "imp-init.el"
    - [X] 178  (defconst imp-path-filename-features "imp-features.el"
    - [X] 186  (defun imp-path-canonical (path &optional root)
    - [X] 194  (defun imp-path-join-canonical (&rest path)
    - [X] 210  (defun imp-path-abbreviate (&rest path)
    - [X] 218  (defun imp--path-relative (feature-or-root path &optional error?)
    - [X] 317  (defun imp-path-relative (feature-or-root &rest path)
    - [X] 348  (defun imp--path-root-dir (feature-base &optional no-error?)
    - [X] 366  (defun imp--path-file-exists? (root &rest paths)
    - [X] 383  (defun imp--path-strings? (root &rest paths)
    - [X] 391  (defun imp--path-root-file-init (feature-base &optional no-exist-check)
    - [X] 440  (defun imp--path-root-file-features (feature-base &optional no-exist-check)
    - [X] 474  (defun imp--path-root-contains? (feature-base)
    - [X] 479  (defun imp--path-root-valid? (caller path &rest kwargs)
    - [X] 569  (defun imp--path-safe-string (symbol-or-string)
    - [X] 614  (defun imp--path-safe-list (feature)
    - [X] 628  (defun imp--path-dir? (path)
    - [X] 639  (defun imp-path-parent (path)
    - [X] 671  (defun imp--path-filename (path)
    - [X] 681  (defun imp-path-current-file ()
    - [X] 708  (defun imp-path-current-file-relative (&optional feature-or-root)
    - [X] 742  (defun imp-file-current ()
    - [X] 747  (defun imp-path-current-dir ()
    - [X] 754  (defun imp-path-current-dir-relative (feature/base)
    - [X] 818  (defvar imp--path-path-platform-case-insensitive
    - [X] 826  (defun imp--path-platform-agnostic (path)
    - [X] 849  (defun imp--path-to-str (input)
    - [X] 884  (defun imp--path-append (parent next)
    - [X] 912  (defun imp-path-join (&rest path)
    - [X] 927  (defun imp--path-sans-extension (&rest path)
    - [X] 937  (defun imp--path-canonical (root relative &optional assert-exists sans-extension)
    - [X] 1085 (defun imp-path-root-set (feature-base path-dir-root &optional path-file-init path-file-features)
    - [X] 1128 (defun imp-path-root-get (feature-base &optional no-error?)
    - [X] 1148 (defun imp--path-init ()

  - [ ] source/core/packages/imp/flag.el
    - [ ] 33   (defvar imp--feature-flags nil
    - [ ] 56   (defun imp--flag-split (flag)
    - [ ] 93   (defun imp--flag-compare (flag-a flag-b)
    - [ ] 130  (defun imp--flag-exists? (feature flag)
    - [ ] 157  (defmacro imp-flag? (feature flag)
    - [ ] 187  (defmacro imp-flag (feature &rest flag)

  - [ ] source/core/packages/imp/timing.el
    - [ ] 46   (defcustom imp-timing-enabled? nil
    - [ ] 52   (defcustom imp-timing-buffer-tail? t
    - [ ] 59   (defconst imp-timing-feature? (imp-flag? :imp +timing)
    - [ ] 63   (defun imp-timing-enabled? ()
    - [ ] 77   (defconst imp-timing-format-tree
    - [ ] 92   (defconst imp--timing-precision 4
    - [ ] 96   (defvar imp--timing-indent 0
    - [ ] 106  (defvar imp--timing-feature-current nil
    - [ ] 115  (defvar imp-timing-sum 0.0
    - [ ] 123  (defcustom imp-timing-buffer-name
    - [ ] 135  (defcustom imp-timing-buffer-show t
    - [ ] 141  (defcustom imp-timing-format-load "loading %1$S..."
    - [ ] 153  (defcustom imp-timing-format-skip "skip: %1$S"
    - [ ] 165  (defcustom imp-timing-reason "reason: "
    - [ ] 179  (defcustom imp-timing-format-skip-already-provided "feature already provided"
    - [ ] 191  (defcustom imp-timing-format-skip-optional-dne "optional file does not exist: %3$s"
    - [ ] 203  (defcustom imp-timing-format-time-total
    - [ ] 240  (defcustom imp-timing-format-time
    - [ ] 255  (defcustom imp-timing-separator-restart
    - [ ] 264  (defcustom imp-timing-separator-final
    - [ ] 277  (defun imp--timing-feature-duplicate? (feature)
    - [ ] 293  (defun imp--timing-tree-type (type indent)
    - [ ] 323  (defun imp--timing-tree-string (type)
    - [ ] 336  (defun imp--timing-buffer-messages? ()
    - [ ] 352  (defun imp-timing-buffer-name ()
    - [ ] 361  (defun imp--timing-buffer-get (&optional buffer-or-name &rest args)
    - [ ] 391  (defun imp--timing-buffer-tail ()
    - [ ] 415  (defun imp--timing-buffer-show (force-show?)
    - [ ] 424  (defun imp-cmd-timing-buffer-bury (&optional ignore-messages-buffer)
    - [ ] 443  (defun imp-cmd-timing-buffer-kill (&optional ignore-messages-buffer)
    - [ ] 466  (defun imp--timing-buffer-insert (string)
    - [ ] 519  (defun imp--timing-message (type formatting &rest args)
    - [ ] 529  (defun imp--timing-start (feature filename path)
    - [ ] 540  (defun imp--timing-end (time:start)
    - [ ] 553  (defun imp-timing-skip-already-provided (feature filename path)
    - [ ] 575  (defun imp-timing-skip-optional-dne (feature filename path)
    - [ ] 597  (defmacro imp-timing (feature filename path &rest body)
    - [ ] 646  (defun imp-timing-restart ()
    - [ ] 672  (defun imp--timing-final (&optional separator-line?)
    - [ ] 687  (defun imp--timing-final-timer (&optional separator-line?)
    - [ ] 707  (defun imp-timing-final (&optional separator-line?)
    - [ ] 726  (defun imp--timing-mode-font-lock-keywords-element-create (matcher subexp facename &optional override laxmatch)
    - [ ] 777  (defconst imp--timing-mode-font-lock-keywords
    - [ ] 972  (defconst imp--timing-mode-font-lock-defaults
    - [ ] 1018 (defvar imp-timing-mode-map

  - [ ] source/core/packages/imp/provide.el
    - [ ] 52   (defalias 'imp-provided? 'imp-feature?)
    - [ ] 53   (defalias 'imp-providedp 'imp-feature?)
    - [ ] 56   (defun imp-provide-to-imp (&rest feature)
    - [ ] 86   (defun imp-provide-to-emacs (&rest feature)
    - [ ] 107  (defun imp-provide (&rest feature)
    - [ ] 128  (defun imp--unprovide-feature-from-emacs (&rest feature)
    - [ ] 142  (defun imp--unprovide-tree-from-emacs (normalized tree)
    - [ ] 149  (defun imp-unprovide (&rest feature)

  - [ ] source/core/packages/imp/load.el
    - [ ] 33   (defun imp--load-file (filepath)
    - [ ] 62   (defun imp--load-paths (feature path-root paths-relative)
    - [ ] 106  (defun imp--load-feature (&rest feature)
    - [ ] 271  (defun imp--load-parse (caller path-current-dir plist-symbol-name plist)
    - [ ] 525  (defmacro imp-load (&rest load-args-plist)

  - [ ] source/core/packages/imp/require.el
    - [ ] 33   (defun imp-require (&rest feature)

  - [ ] source/core/packages/imp/package.el
    - [ ] 102  (defmacro imp-use-package (name &rest args)
    - [ ] 138  (defmacro imp-eval-after (feature &rest body)

  - [ ] source/core/packages/imp/commands.el
    - [ ] 31   (defcustom imp-output-features-buffer
    - [ ] 42   (defun imp-cmd-features-print ()
    - [ ] 53   (defun imp-cmd-features-nuke ()


also check for ones to declare in like
  (declare (pure t)
           (side-effect-free t)
           (important-return-value t))

got bored.
ok.
moving on...

** settings.el

move all defcustoms to settings.el
load settings first(?)

** imp-load bugs

Do minimum now.
Do better after emacs is more than limping along.



Macro can't deal with funcs properly:
  (imp-load :feature '(:user config org)
            :path (imp-path-join 'user 'config 'org)
            )

Debugger entered--Lisp error: (wrong-type-argument stringp (imp-path-join 'user 'config 'org))
  expand-file-name((imp-path-join 'user 'config 'org) "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
  (setq out-path (expand-file-name in-filename in-path))


Probably not a bug??:
  (imp-load :feature '(:user config org)
            :path  "user/config/org"
            )


Debugger entered--Lisp error: (file-missing "Cannot open load file" "No such file or directory" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/user/config/org")
  load("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/user/config/org" nil nomessage)

I think moving that one call out in front of macro expansion was probably bad for short term stability.

Uh.....
I think this requires more than minimum to fix....

So the minimum is... fix the callers?

* ├DONE───┤ file timestamp auto-update
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-06-03 Tue 22:38]
- State "├CURRENT┤"  from "├DONE───┤"  [2025-06-03 Tue 22:37]
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

mantle/config/dev-env/languages/emacs-lisp.el
163     (emacs-lisp-mode-hook . mantle:hook:time-stamp:settings)

[[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el]]

[[file:init.el::;; PRIORITY: Everything: Emacs Settings]]
;; TODO: More from: file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el
;; (add-hook 'before-save-hook 'time-stamp)



* ├DONE───┤ disable some annoying keybinds
CLOSED: [2025-06-03 Tue 22:34]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:34]
:END:

new funcs?
  keymap-unset
  keymap-global-unset

Disable C-z
Disable C-mousewheel (font size +/-)


* ├DONE───┤ switch to zenburn
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:38]
:END:

~hc-zenburn-theme~ is unmaintained.

Move from ~hc-zenburn-theme~ back to ~zenburn-theme~.


* ├DONE───┤ innit
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:38]
:END:

Need the face funcs.
So start porting.

~/ocean/vault/.config/emacs/2023-07-23_sn004/core/modules/emacs/innit

steal funcs from sn004 or steal all namespaced libs?
 - Turns out: first the one, then the other.

Just the face funcs for now:
file:~/ocean/vault/.config/emacs/2023-07-23_sn004/core/modules/emacs/innit/theme.el

Need:
  - [X] ns:str
    - ~str:normalize:join~
  - [X] ns:list
    - ~elisp:list:listify~ -> ~list:to-list~?

back to the face funcs:      
[[file:source/core/packages/namespaced/theme/face.el]]

Annnd... it loads!

hm....
Do I even want to keep this Doomism?
Just convert to the Emacs version and just call the Emacs funcs?
Keep Doom->Emacs func but make others work on the converted?

meh. As-is works for Doom and[or Emacs face specs.

What the hell was I doing all this for?
  - oh right; org-mode todo keywords. Go [[*org][here]].

* ├DONE───┤ zenburn & org
CLOSED: [2025-06-03 Tue 22:39]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:39]
:END:

old zen+org: [[file:source/user/config/theme/zenburn/org-mode.el][here]]
new zen+org: [[file:source/user/config/org/theme/zenburn.el][here]]

Get my zenburn fixes for org-mode in.

~mode:org:todo/keyword~ is what now?

Where'd I put this func again???
mode:org:todo/keywords

rg '(mode)?.*org.*todo.*keyword'
find -name link.el
find -name keyword.el

mmh... nowhere, looks like.

copied:
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/init.el
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/keyword.el
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/link.el

Need:
  - ~buffer:region:get~
  - :buffer 'delete
k

Where was I?..
back to new zen+org: [[file:source/user/config/org/theme/zenburn.el][here]]
  - k

...and then?
everything done?

* ├DONE───┤ completion
CLOSED: [2025-06-04 Wed 16:27]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-04 Wed 16:27]
:END:

corfu, vertico, etc

get from sn-004
  - k

[[file:source/user/config/completion.el]]



* ├DONE───┤ yasnippets
CLOSED: [2025-09-09 Tue 23:50]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:50]
- State "├CURRENT┤"  from              [2025-09-09 Tue 22:34]
:END:

** ├DONE───┤ 004's snippets
CLOSED: [2025-09-09 Tue 22:34]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-09 Tue 22:34]
:END:

Need my begin_src snippet...
#+begin_src bash
cd /home/main/ocean/vault/.config/emacs/2023-07-23_sn004
cp -r snippets ../2025-03-13_sn005/
#+end_src

** ├DONE───┤ use package
CLOSED: [2025-09-09 Tue 23:41]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:41]
- State "├CURRENT┤"  from              [2025-09-09 Tue 22:37]
:END:

Where is it in 004?
#+begin_src console
2023-07-23_sn004 on  main [!?] 
❯ rg "use-package.*yas"
mantle/config/dev-env/snippets.el
111:(imp:use-package yasnippet
574:(imp:use-package yasnippet
636:(imp:use-package yasnippet
#+end_src

file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/dev-env/snippets.el

test:

#+begin_src yaml
foo:
  bar:
    - baz
    - qux
#+end_src




** ├DONE───┤ new snippets
CLOSED: [2025-09-09 Tue 23:48]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:48]
- State "├CURRENT┤"  from              [2025-09-09 Tue 23:41]
:END:

/todo/penis
                             TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO.
TODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
ODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
DO TODO TODO TODO TODO TODO TODO TODO TODO'
O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

/todo/penis
                             TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO.
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             ODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             DO TODO TODO TODO TODO TODO TODO TODO TODO'
                             O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO
meh.
hm...
back to drawing board...


* ├DONE───┤ line/column
CLOSED: [2025-09-11 Thu 22:10]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-11 Thu 22:10]
:END:

old sn004: file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el
new sn005: file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/emacs.el


* ├DONE───┤ FIX: timestamps
CLOSED: [2025-09-12 Fri 14:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-12 Fri 14:38]
:END:

...timestamps stopped working???
[[file:init.el::;; (Automatic) Time Stamps]]

oh. they never started working.
I need my elisp mode config so elisp files start timestamping.
  - well it works but...
...timestamps remain unchanging.

time-stamp-start
  - org-mode hook runs time-stamp settings hook
  - elisp does not

--/hook/time-stamp/settings
--/hook/time-stamp/before-save

ok. it wasn't this it was other stuff.
errors and bad hooks in elisp mode

* ├DONE───┤ recentf
CLOSED: [2025-09-22 Mon 13:18]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-22 Mon 13:18]
- State "├CURRENT┤"  from              [2025-09-22 Mon 12:00]
:END:

sn004 config:
file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/files.el

sn005:
[[file:source/user/config/files.el]]

* ├DONE───┤ ns/unit
CLOSED: [2025-09-22 Mon 15:17]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-22 Mon 15:17]
:END:
* ├DONE───┤ ns/datetime
CLOSED: [2025-09-22 Mon 16:37]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-22 Mon 16:37]
:END:

* ├DONE───┤ elisp mode config
CLOSED: [2025-09-23 Tue 23:04]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-23 Tue 23:04]
- State "├CURRENT┤"  from "├DONE───┤"  [2025-09-12 Fri 14:29]
- State "├DONE───┤"  from              [2025-09-12 Fri 14:15]
:END:

these have weird complaints when evaluating right now
  - [[file:source/user/config/languages/elisp.el::(use-package highlight-quoted]]
  - [[file:source/user/config/languages/elisp.el::use-package macrostep]]

+Ok. Restarted Emacs and init for those works fine now.+
load of elisp.el was not added to init.

** ├DONE───┤ Errors
CLOSED: [2025-09-23 Tue 22:19]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-23 Tue 22:19]
:END:

Get these errors:
#+begin_src warnings
⛔ Error (use-package): Cannot load macrostep
⛔ Error (use-package): Cannot load elisp-demos
#+end_src

https://github.com/jwiegley/use-package/issues/768
use this to debug?:
#+begin_src elisp
(setq use-package-verbose t
            use-package-expand-minimally nil
            use-package-compute-statistics t
            debug-on-error t)

(defun use-package-require (name &optional no-require body)
  (if use-package-expand-minimally
      (use-package-concat
       (unless no-require
         (list (use-package-load-name name)))
       body)
    (if no-require
        body
      (use-package-with-elapsed-timer
          (format "Loading package %s" name)
        `((if (not ,(use-package-load-name name))
              (display-warning 'use-package
                               (format "Cannot load %s" ',name)
                               :error)
            ,@body))))))

(use-package macrostep)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (file-missing "Cannot open load file" "No such file or directory" "macrostep")
  require(macrostep nil nil)
  (not (require 'macrostep nil nil))
  (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t))
  (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract (current-time) now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))
  (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract (current-time) now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep")))))
  (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract ... now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t))
  (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time ...))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err)))
  (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let ((msg (format "%s/%s: %s" ... keyword ...))) (display-warning 'use-package msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require ... nil nil)) (display-warning 'use-package (format "Cannot load %s" ...) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed ...)) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t))
  (progn (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let ((msg ...)) (display-warning 'use-package msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not ...) (display-warning ... ... :error) (use-package-statistics-gather :config ... nil) (use-package-statistics-gather :config ... t)) (let (...) (if ... ... ...)))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t)))
  eval((progn (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let (...) (display-warning ... msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now ...)) (message "%s..." "Loading package macrostep") (prog1 (if ... ... ... ...) (let ... ...))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x8fa3722e129a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x8fa3722e129a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

so..... it didn't install the package?

maybe I need melpa at front of list instead of back?
  nope

maybe I need to delete a bad install?

restart emacs to clean up package stuff?
  - that worked. ~use-package macrostep~ worked; ~macrostep~ is installed.

Uncomment ~elisp-demos~ & eval
  - k; good

** ├DONE───┤ Hooks
CLOSED: [2025-09-23 Tue 23:04]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-23 Tue 23:04]
:END:

And I guess these need fixed too:
(remove-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode)
(remove-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)

* ├DONE───┤ whitespace
CLOSED: [2025-09-24 Wed 14:07]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-24 Wed 14:07]
- State "├CURRENT┤"  from              [2025-09-09 Tue 23:55]
:END:

cleanup
butler
visuals
etc

old sn004: [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/whitespace.el]]
new sn005: file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/whitespace.el

get theme fixes for whitespace mode
[[file:source/user/config/theme/zenburn/whitespace.el]]

* ├DONE───┤ org eval src blocks: shells
CLOSED: [2025-10-08 Wed 21:57]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-08 Wed 21:57]
- State "├CURRENT┤"  from              [2025-10-08 Wed 21:50]
:END:

Want to be able to eval bash...

InternGPT says:
#+begin_quote
To enable evaluating source blocks for Bash in Emacs Lisp when using Org-mode,
you need to ensure that the =ob-shell= package is loaded or required, and the
language is included in the list of supported languages for evaluation. You can
achieve this by adding the following code to your Emacs configuration:

#+begin_src lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t))) ; Enable evaluation for shell scripts (including bash)
#+end_src

Make sure Org-mode is installed and configured in your Emacs setup. After adding
this code, you can evaluate shell source blocks within Org-mode documents. Note
that it's important to be cautious and understand the security implications of
executing code blocks.
#+end_quote

#+begin_src bash
ls
#+end_src

#+RESULTS:
| 42.org         |
| auto-save-list |
| early-init.el  |
| eln-cache      |
| elpa           |
| etc            |
| init.el        |
| LICENSE        |
| scripts        |
| snippets       |
| source         |
| symlink.sh     |
| var            |

yay

* ├DONE───┤ fix: treesit & JSON
CLOSED: [2025-10-08 Wed 22:25]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:25]
:END:

** ├DONE───┤ install tree-sitter grammar
CLOSED: [2025-10-08 Wed 22:32]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:32]
:END:

#+begin_quote
⛔ Warning (treesit): Cannot activate tree-sitter, because language grammar for json is unavailable (not-found): /home/main/.config/emacs/tree-sitter/libtree-sitter-json: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.14.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.13.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.0.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.14.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.13.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.0.0: cannot open shared object file: No such file or directory libtree-sitter-json: cannot open shared object file: No such file or directory libtree-sitter-json.14.0: cannot open shared object file: No such file or directory libtree-sitter-json.13.0: cannot open shared object file: No such file or directory libtree-sitter-json.0: cannot open shared object file: No such file or directory libtree-sitter-json.0.0: cannot open shared object file: No such file or directory libtree-sitter-json.so: cannot open shared object file: No such file or directory libtree-sitter-json.so.14.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.13.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.0.0: cannot open shared object file: No such file or directory
#+end_quote

google:
Cannot activate tree-sitter, because language grammar for json is unavailable (not-found)

https://www.masteringemacs.org/article/how-to-get-started-tree-sitter
~M-x treesit-install-language-grammar~

So... do that thing then.

** ├DONE───┤ use treesit when viewing JSON
CLOSED: [2025-10-08 Wed 22:49]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:49]
:END:

So... now am I using treesit when I open JSON file?
  - no. I'm using ~js-json-mode~ instead of ~json-ts-mode~.

Need a JSON config file.
  - old one? file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/dev-env/languages/json.el

make:
file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/languages/json.el

** ├DONE───┤ Get json highlights working in src blocks
CLOSED: [2025-10-08 Wed 22:51]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:51]
:END:

#+begin_src json
{
    "test": true,
    "greeting": "Hello there."
}
#+end_src

fix in [[file:source/user/config/org/mode.el::push '("json" . json-ts) org-src-lang-modes][org/mode.el]]
#+begin_src elisp
  (push '("json"                    . json-ts)    org-src-lang-modes)
#+end_src



* ├DONE───┤ helpful & which-key
CLOSED: [2025-10-09 Thu 14:29]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-09 Thu 14:29]
- State "├CURRENT┤"  from              [2025-10-09 Thu 14:25]
:END:

old: file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/help.el
make:
file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/help.el


* ├DONE───┤ gptel: GPT 5?
CLOSED: [2025-10-10 Fri 15:42]
:LOGBOOK:
- State "├DONE───┤"  from "├SUCCESS┤"  [2025-10-10 Fri 15:42]
- State "├SUCCESS┤"  from "├CURRENT┤"  [2025-10-10 Fri 15:42]
- State "├CURRENT┤"  from              [2025-10-10 Fri 14:32]
:END:

move config to ~source/user/config/ai.el~

update from 4o to 5
  - [[file:source/user/config/ai.el::gptel-model 'gpt-5][here]]

* -- U R HERE --
<<here>>

* org-babel no confirm

write a func that ~org-confirm-babel-evaluate~ can use to decide
whether to prompt with ~y-or-n-p~

by source type (major-mode)?

* ├CURRENT┤ IMP-FIX: imp-load
:LOGBOOK:
- State "├CURRENT┤"  from              [2025-09-25 Thu 15:44]
:END:

After restarting emacs & returning to this branch:
#+begin_src elisp
;; reload imp to get new code.
(load (expand-file-name "source/core/packages/imp/init.el" user-emacs-directory))
(imp-path-root-set 'imp "~/.config/emacs/source/core/packages/imp/")
#+end_src

** ├DONE───┤ use-package parser
CLOSED: [2025-10-16 Thu 16:37]
:PROPERTIES:
:ORDERED:  t
:END:
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 16:37]
- State "├CURRENT┤"  from              [2025-09-25 Thu 15:44]
:END:

Make load parse its args like use-package does?
  - ur [[file:source/core/packages/imp/parser.el::provide 'use-package-core][here]]
    - Refactor that to be useful to imp.

Mmh...
(setq imp-parser-verbose 'debug)
then see how it goes?


(setq imp-parser-verbose nil)
(setq imp-parser-verbose 'errors)
(setq imp-parser-verbose 'debug)
(imp-parser foo)
(imp-parser foo :optional t)
(imp-parser foo :optional t :error t)

(imp-parser foo :path (imp-path-current-dir))

And then:
  - [X] make defaults [[file:source/core/packages/imp/parser.el::(defcustom imp-parser-defaults][here]]
  - [ ] Make bare minimum work:
    - (imp-parser foo)
      - load from PWD or load-paths?
    - (imp-parser :user test)
      - load test from :user root?
      - Should I change to something like (imp-parser user/test)?

So... I need the handlers to call the load func once they're all done?
So... ~imp-parser-process-keywords~ needs the logic.
  - [[file:source/core/packages/imp/parser.el::;; TODO: (if (null plist)][imp-parser-process-keywords]]
  - [[file:source/core/packages/imp/parser.el::defun imp-parser-load (name state][imp-parser-load]]

(setq imp-parser-verbose nil)
(setq imp-parser-verbose 'debug)
(imp-parser foo)
(imp-parser foo :optional t)
(imp-parser foo :optional t :error t)

Make path normalizer more dumb?
  - Make the defaults an ordered list?
  - Make people use ":/" or ~FOO:/blah~ or ~(from-)feature(-root)~ for feature-rooted paths?
  - Make people use "./" or ~pwd~ for ~imp-path-current-dir~?
  - Maybe get it down to the only guess being ~user-emacs-directory~?

Check path normalizer/handler.

(imp-parser-normalize/:path :user/foo :path '(nil))
(imp-parser-normalize/:path :user/foo :path '(root))
(imp-parser-normalize/:path :user/foo :path '(.emacs.d))
(imp-parser-normalize/:path :user/foo :path '(cwd))

k

maybe I should try an actually bound symbol?
(imp-parser-normalize-path :user :path 'user-emacs-directory)
(imp-parser-normalize/:path :user/foo :path '(user-emacs-directory))
Yay. It follows its symlink.

Make file that can be loaded many times.
  - w/ just a message or something in it.
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el


Refactor ~imp/feature.el~ for new style features.
  - [[file:source/core/packages/imp/feature.el][here]]
look for ~TODO-HERE~
  - [X] k

#+begin_src elisp
;; TODO-HERE: Which is a rooted feature?
;; :root/first/second
;; root:/first/second
#+end_src
  - [[file:source/core/packages/imp/feature.el::;; TODO-HERE: Which is a rooted feature?][here]]
  - [X] k

Honestly I should be on an imp branch...
  - [X] k

ok
I think I have all the `imp-feature` things I need now.

Fix default path w/ feature root:
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
(imp-parser '(imp test data/load manual-test))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  file-name-nondirectory(nil)
  imp--path-filename(nil)
  (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-to-list name))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or ... ...)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))
  (let* ((funcname "imp-parser-load") (path (plist-get state :path))) (if imp--debugging? (progn (imp--debug funcname "load '%s'" path-load))) (let ((imp--macro-feature (imp--feature-normalize-to-list name))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (load path (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))))
  imp-parser-load(imp:/test/data/load/manual-test nil)
...
#+end_src

Hmmm... I need a normalizer and handler for NAME/FEATURE in imp-parser.

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
(imp-parser (imp test data/load manual-test))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument listp t)
  cdr(t)
  macroexp-progn(t)
  (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))
  (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*)))))
...
#+end_src

Now I need to return a form so the macro works.

and then?
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

...imp-timing macro is sad.
make one that returns forms instead of evals them?
or do I have one?

How do I debug the macro expansion anyways?
  - ~macrostep~ doesn't work.

How 'bout this?
#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing 'imp:/test/data/load/manual-test "manual-test"
:              "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
:    (load
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))

need to eval all the state gets.
  - k

#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing 'imp:/test/data/load/manual-test "manual-test"
:              "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
:    (load
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (not (or nil nil)) 'nomessage)))

...imp-timing macro is probably still sad.
make one that returns forms instead of evals them
  - ~imp-timing-core~?
    - [[file:source/core/packages/imp/timing.el::defmacro imp-timing-core (feature filename path &rest body][yeah]]
Make that thing work.
And only take a path.
[[file:source/core/packages/imp/timing.el::defmacro imp-timing-core (feature filename path &rest body][yeah]] go here.

#+begin_src elisp
(imp-timing-core 'imp:/test/data/load/manual-test/1
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
    (message "Hello there."))
#+end_src

that might work maybe?

#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing-core 'imp:/test/data/load/manual-test
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      (load
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:       (not (or nil nil)) 'nomessage)))

Maybe. Try it.

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (invalid-function (let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  (progn ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))))
  eval((progn ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent ...)) (load "name" (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x480b065b629a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x480b065b629a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src


#+begin_src elisp
(pp-to-string (imp-parser-load 'imp:/test/data/load/manual-test nil))
#+end_src

#+RESULTS:
#+begin_example elisp
((let ((imp--macro-time (current-time)))
   (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
   (imp--timing-start 'imp:/test/data/load/manual-test
                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
   (prog1
       (let ((imp--timing-indent (1+ imp--timing-indent)))
         (load
          "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
          (not (or nil nil)) 'nomessage))
     (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
#+end_example

That looks right, right?


#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
#+begin_example elisp
((let ((imp--macro-time (current-time)))
   (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
   (imp--timing-start 'imp:/test/data/load/manual-test
                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
   (prog1
       (let ((imp--timing-indent (1+ imp--timing-indent)))
         (load
          "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
          (not (or nil nil)) 'nomessage))
     (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
#+end_example

Also looks right, right?

#+begin_src elisp
(macroexpand (imp-parser imp:/test/data/load/manual-test))
#+end_src

Annd... I got:
#+begin_quote
loading name...
└─00.0057 seconds
#+end_quote

#+begin_src elisp
(imp-parser-handler/:requires 'foo :requires '(bar) nil nil)
#+end_src
hm....

#+begin_src elisp
(macroexpand (imp-parser imp:/test/data/load/manual-test))
#+end_src

#+begin_src elisp
(pp-to-string (imp-timing-core imp:/test/data/load/manual-test/1
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
    (message "Hello there.")))
#+end_src
better maybe?

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (void-variable let)
  (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (progn (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  eval((progn (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x480b065b629a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x480b065b629a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

nope.

SIIIIIGH
I wish I knew how to expand macros one step at a time....

#+begin_src elisp
(pp-to-string
 (macroexp-progn
  (imp-parser-concat
   (imp-parser-core imp:/test/data/load/manual-test nil))))
#+end_src

#+RESULTS:
#+begin_example elisp
(let ((imp--macro-time (current-time)))
  (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
  (imp--timing-start 'imp:/test/data/load/manual-test
                     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
  (prog1
      (let ((imp--timing-indent (1+ imp--timing-indent)))
        (load
         "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
         (not (or nil nil)) 'nomessage))
    (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
#+end_example

Hmm.... ~load.el~ won't load right now.
#+begin_src elisp
(load (expand-file-name "source/core/packages/imp/load.el" user-emacs-directory))
#+end_src

That fails because of ~imp--load-paths~
~imp--load-paths~ because of ~imp-timing~
~imp-timing~ still had a ~filename~ var; deleted.

#+begin_src elisp
(load (expand-file-name "source/core/packages/imp/load.el" user-emacs-directory))
#+end_src
yay

so imp-parser-core works
Why doesn't imp-parser work? :(
I broke use-package's parser :((

restart & reload...
  - that always fixes things. :fingers-crossed:

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

ok. This is better than last night.
#+begin_src backtrace
Debugger entered--Lisp error: (void-variable state)
  (plist-get state :error)
  (or (plist-get state :error) (plist-get state :optional))
  (not (or (plist-get state :error) (plist-get state :optional)))
  (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)
  (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))
  (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or ... ...)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))
  (progn (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))))
  eval((progn (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let (...) "imp/test/data/load" (load "imp/test/data/load/manual-test" ... ...)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

Oh. It works-ish?
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src
Didn't get any timing this time, but:

#+begin_quote
Loading ’manual-test.el’ for 0 time...
t
#+end_quote
I loaded it for the first time.
  - yay.
I got back a ~t~ return value.
  - yay.

With timing this time tho?

Oh; this is how macroexpand works. You gotta quote it.
#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser imp:/test/data/load/manual-test))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test "manual-test" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))

Oh. this still has filename & dir path.
Need just filepath.
#+begin_src elisp
(imp-timing 'imp:/test/data/load/manual-test
    "manual-test"
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
(load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))
#+end_src

#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser imp:/test/data/load/manual-test))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))

Oh. I'm not using ~imp-timing-core~.
:thinking:
If it works, use it?

#+begin_src elisp
(macroexpand-1
 (imp-timing 'imp:/test/data/load/manual-test
     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
     (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
           (not (or nil nil))
           'nomessage)))
#+end_src

#+RESULTS:
: t

Aw... Still no timing message.
Is timing enabled?
oh; clear current feature.
#+begin_src
imp--timing-feature-current
(setq imp--timing-feature-current nil)
#+end_src

#+begin_src elisp
(imp-timing 'imp:/test/data/load/manual-test
     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
     (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
           (not (or nil nil))
           'nomessage))
#+end_src

#+RESULTS:
: t

yay. got timing message.
#+begin_quote
loading imp:/test/data/load/manual-test...
└─00.0075 seconds
#+end_quote

And then....?
  - [X] commit
  - [ ] test with args

I think that counts as
  - [X] Make bare minimum work

and this headline is long
TO THE NEXT HEADLINE!

** ├DONE───┤ imp-parser keywords: ~optional~, ~error~
CLOSED: [2025-10-16 Thu 17:21]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 17:21]
- State "├CURRENT┤"  from              [2025-10-16 Thu 16:41]
:END:

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test :optional t :error t)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      (not (or :error :optional)) 'nomessage))

Ok, so the args show up in the macro output.

optional file that DNE:
#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test :optional t :error nil)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      'noerror 'nomessage))

Add defaults for:
  -  ~:error~; should be true.
  -  ~:optional~; should be false.

and this should have a nil for ~noerror~ param
#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      nil 'nomessage))

yay

so this should error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist)
#+end_src

it did.

and this should not error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

#+RESULTS:

it did not error.
  - yay

also this should not error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :error nil)
#+end_src

#+RESULTS:

it did not error.
  - yay

However, imp-timing doesn't know about whether optionals exist or not.

** ├DONE───┤ more info about optional files
CLOSED: [2025-10-16 Thu 20:29]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 20:29]
- State "├CURRENT┤"  from              [2025-10-16 Thu 17:23]
:END:

We should get "optional file dne; skipping" info in the imp-timing buffer for this:
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

~imp-load~ does it like so:
#+begin_src elisp
;;---
;; Optional?
;;---
;; Skip if optional and file doesn't exist.
((and imp--macro-optional?
      (not (file-exists-p imp--macro-path-file)))
 ;; Skip w/ optional timing message.
 (imp-timing-skip-optional-dne imp--macro-feature
                               imp--macro-name-load
                               imp--macro-path-file)
 (setq imp--macro-load-file? nil)
 ;; Return nil for 'did not load'.
 (setq imp--macro-load-result nil))
#+end_src
  - [[file:source/core/packages/imp/load.el::;; Optional?][here]]

make imp-path-has-load-extension work
  - k

fix imp-path-load-file to work if path already has ext
  - k

#+begin_src elisp
(imp-path-load-file "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test")
(imp-path-load-file "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test.el")
(imp-path-has-load-extension "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test")
(imp-path-has-load-extension "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test.el")
#+end_src

hokay...
use those somewhere...
~imp-parser-load~

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/does-not-exist :optional t)))
#+end_src

#+RESULTS:
: (progn
:   (imp-timing-skip-optional-dne 'imp:/test/data/load/does-not-exist
:                                 "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist")
:   nil)


#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

#+begin_quote
skip: imp:/test/data/load/does-not-exist
│ └─reason: optional file does not exist: /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist
#+end_quote

** ├DONE───┤ imp-parser keyword: ~:path~
CLOSED: [2025-10-16 Thu 21:27]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-16 Thu 21:27]
:END:

So this works.
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist)
#+end_src

Will this work?
Can't remember if it assumes ~user-emacs-directory~ if it has nothing.
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test)
#+end_src

Nope. It has no path so it assumes nothing.
#+begin_quote
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-load:
Cannot find a file to load.
path:’source/core/packages/imp/test/data/load/manual-test’ -> load-path:’nil’")
#+end_quote

er... now the warnings buffer says
#+begin_quote
⛔ Error (imp-parser): Failed to parse package source/core/packages/imp/test/data/load/manual-test: Wrong type argument: stringp, nil
#+end_quote

Oh. That's the condition case that catches the error.
...do I even want to catch that error?
  - No. Lose top level ~condition-case~
    - k

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 (imp-parser source/core/packages/imp/test/data/load/manual-test)))
#+end_src

#+begin_quote
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  file-name-absolute-p(nil)
#+end_quote

the new check is doin' it.
  - fixed

add a path
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test
  :path .emacs)
#+end_src

#+begin_quote
Debugger entered--Lisp error: (error "[ERROR--]:
imp-parser-load: Cannot find a file to load.
path:’/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test’
 -> load-path:’nil’")
#+end_quote

That should be the path...?
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el
yeah, that's the file.

So why is path-load nil?

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser source/core/packages/imp/test/data/load/manual-test
    :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-timing 'source/core/packages/imp/test/data/load/manual-test
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:       (imp--error 'imp-parser-load
:                   "Cannot find a file to load. path:'%s' -> load-path:'%s'"
:                   "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:                   nil))
:   nil)

hmm... sus.
#+begin_src elisp
    (message "path: %S" path)
    (message "load: %S "(imp-path-load-file path))

    ;; Convert path to a load path.
    (let (path-load (imp-path-load-file path))

      (message "path: %S" path)
      (message "path-load: %S " path-load)
      (message "load: %S " (imp-path-load-file path))
#+end_src

#+begin_quote
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
load: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
path-load: nil
load: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
#+end_quote

oh. Not enough parens.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser source/core/packages/imp/test/data/load/manual-test
    :path .emacs)))
#+end_src

#+RESULTS:
: (imp-timing 'source/core/packages/imp/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      'nil 'nomessage))

k.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test
  :path user-emacs-directory)
#+end_src
  - works

Good enough for now.


** ├CURRENT┤ imp-parser keyword: ~:root~?
:LOGBOOK:
- State "├CURRENT┤"  from              [2025-10-16 Thu 21:55]
:END:

Allow adding a dir as a feature's root.

so this should add to ~imp-path-roots~:
#+begin_src elisp
(setq imp--timing-feature-current nil)
;; TODO: delete from root paths
(imp-parser imp:/test/data/load/does-not-exist
  :optional t
  :root 'itdl
)
#+end_src

expect ~(itdl "~/.config/emacs/source/core/packages/imp/test/data/load/" nil)~ in:
#+begin_src elisp
(pp-to-string imp-path-roots)
#+end_src

I need to do a thing after load.
  - which will probably mess up how load works, since it assumes it's last.
Add a secret keyword for "load happens here in the turn order"?

And I need the full real actual path so I can make the root.
  - So load will need to put that in the plist when its done?

Or I need to get the full real actual path during path handling.

move code in
  - [[file:source/core/packages/imp/parser.el::;; Figure out path from FEATURE?][imp-parser-load]]
to
  - [[file:source/core/packages/imp/parser.el::;; Add (some of) FEATURE to end of path?][imp-parser-normalize/:path]]

Make ~:path~ default to nil so we always run the path normalization.
Make ~:path~ handler also put load path into ~state~.

Add ~:root~ to the vars
  - [[file:source/core/packages/imp/parser.el::(defcustom imp-parser-keywords][imp-parser-keywords]]
    - Put a comment in there for where the loading should happen.
  - +[[file:source/core/packages/imp/parser.el::(defcustom imp-parser-defaults][imp-parser-defaults]]+
    - Don't wanna do anything if keyword doesn't exist, so don't have a default.

(imp-parser-normalize/:path :user/foo :path '(user-emacs-directory))

(imp-feature-normalize 'test)

#+begin_src elisp
(let ((name 'test/foo/bar)
      (keyword :root)
      (args '(t))
      ;;(args '(test))
      (rest nil)
      (state (list :path (imp-path-current-dir))))
  (imp-parser-normalize/:root name keyword args))
  (imp-parser-handler/:root name keyword (car args) rest state))
#+end_src

Hokay.

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]
kk

~:root~ as flag.
#+begin_src elisp
(imp-parser-only-one
 "hello"
 '("test");(imp-parser-normalize-flag :_ nil)
 #'imp-parser-normalize-symbol-or-string)
#+end_src

#+begin_src elisp
(let ((name 'test/foo/bar)
      (keyword :root)
      args
      ;;(args '(t))
      ;;(args '(test))
      (rest nil)
      (state (list :path (imp-path-current-dir))))
  (imp-parser-normalize/:root name keyword args))
#+end_src
  - k

TEST!

#+begin_src elisp
(pp-to-string imp-path-roots)
#+end_src

#+RESULTS:
#+begin_example
((imp "~/.config/emacs/source/core/packages/imp/" nil)
 (:theme
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme"
  "init.el" nil)
 (:str
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str"
  "init.el" nil)
 (:datetime
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime"
  "init.el" nil)
 (:unit
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit"
  "init.el" nil)
 (:buffer
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer"
  "init.el" nil)
 (:elisp
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp"
  "init.el" nil)
 (:user "~/.config/emacs/source/user" nil nil)
 (:emacs.d "~/.config/emacs/" nil nil)
 (:imp "/home/main/.config/emacs/source/core/packages/imp" "init.el" nil))
#+end_example

#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser temp/init
                  :root
                  :path .emacs))
#+end_src

#+RESULTS:
: (progn (imp-path-root-set 'temp "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp") (imp-timing 'temp/init "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init" 'nil 'nomessage)))

yay?

#+begin_src elisp :results scalar
(list :result (imp-parser temp/init
              :root
              :path .emacs)
      :roots imp-path-roots)
#+end_src

ok.
butt.....
Need to allow dupes in `imp-path-root-set'.

Hm... why was the first set right but now it wants the parent of what it should have?
#+begin_quote
existing: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp"
new:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005"
e == n ?  nil
#+end_quote

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
:   (imp-timing 'temp:/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init" 'nil
:             'nomessage)))

Maybe because root exists, and roots don't add to their path....
So they should and get deduped?

╔════════╦════════════╦══════════════════════════════════════════════════════════════════════════════════════════════════════════╗
╠══TODO══╣            ║                                                                                                          ║
╠══TODO══╬══tomorrow══╣                                            ¡¡¡YOU ARE HERE!!!                                            ║
╠══TODO══╣            ║                                                                                                          ║
╚════════╩════════════╩══════════════════════════════════════════════════════════════════════════════════════════════════════════╝
Commit as is

debug with clean slate


hm... maybe get this working again?
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/does-not-exist
     :optional t)))
#+end_src

** imp-parser keyword: ~:load-message~?

an option to disable the ~'nomessage~ param in call to ~load~
  - [[file:source/core/packages/imp/parser.el::'nomessage)))))][here]]

or maybe a ~:let~ / ~:lexical~?

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]


** imp-parser keyword: ~:timing~

nil
t
"don't show buffer"

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]


** imp-parser keyword: ~:load-suffixes~?

Modify ~load-suffixes~ for one thing's load.

and something for ~load-file-rep-suffixes~ as well?

Or just like a generic ~:vars~ or ~:custom~?

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]

** imp-parser keywords: ~:if~ ~:when~ ~:unless~
** imp-parser keyword: ~:requires~
** imp-parser keyword: ~:after~
** imp-parser keyword: ~:~
** imp-parser NAME

#+begin_src elisp
;;------------------------------
;;;; NAME
;;------------------------------

(defun imp-parser-normalize-name (name)
  ;; TODO: make this func unqoute NAME?
  (imp-feature-normalize name)) ; TODO: or this func?
#+end_src
  - [[file:source/core/packages/imp/parser.el::defun imp-parser-normalize-name (name][here]]

** imp-path

*** Deduplicate when joining paths?

This should give something like:
  "~/.config/emacs/path/to/imp/init"
not:
  "~/.config/emacs/path/to/imp/imp/init"

#+begin_src elisp
(imp-parser imp/init
  :path (imp-path-join user-emacs-directory
                       \"path/to/imp\")
  :root t)
#+end_src

*** path.el
;; TODO: MOVE TO path.el
  - [[file:source/core/packages/imp/parser.el::;; TODO: MOVE TO path.el][here]]

** Do some TODOs
* macrostep-expand broken?

#+begin_src elisp
(defmacro m-test ()
  (message "Hello there!")
  (range-map (apply-partially #'format "%S")
             '((0 . 100000)))
  (message "General Kenobi!"))
;; m-x macrostep-expand this:
(m-test)
#+end_src

IDFK. It hasn't been updated in 2 years.
Delete it?

* TRAMP into Win10 VM

I probably need an ssh server running or something.

* use-package-editor

I wanna be able to eval a ~use-package~ custom var.

#+begin_src elisp
    ;;------------------------------
    :custom
    ;;------------------------------

    ;; (setq gptel-model 'gpt-5)
    (gptel-model 'gpt-4o)
#+end_src

I wanna be able to put the cusor after ~(gptel-model 'gpt-4o)~ and ~eval-last-sexp~.
Instead of having to add ~setq~ (or ideally ~customize-set-variable~) to the front.


* my public IP(s)

is there a package that will figure out my IP for me?

else just make a call to the one that I used for the bash prompt

* auth-source / 1pass

what dis? ~gptel~ uses it by default to find API key.

Can I hook in 1pass?


* gptel: PrivateGPT

gptel can support PrivateGPT
  - see [[file:~/.config/emacs/elpa/gptel-20250818.648/gptel.el::;; - For PrivateGPT: define a backend with `gptel-make-privategpt', which see.][here]]

https://github.com/zylon-ai/private-gpt

Get that running on my work org notes?
* gptel: modify org mode layout?

Can I get, like...

#+begin_quote
human> blah blah blah

InternGPT>
lorem ipsum dolor sit amet...
#+end_quote

Look in [[file:~/.config/emacs/elpa/gptel-20250818.648/gptel-org.el::;;; gptel-org.el --- Org functions for gptel -*- lexical-binding: t; -*-][here]] somewhere.

* namespaced window

want my ~window:kill-or-quit~
  - for ~helpful~: [[file:source/user/config/help.el::;; TODO: needs namespaced:window lib][here]]
  - and ~deadgrep~ maybe?

* ├CURRENT┤ csharp & treesit?
:LOGBOOK:
- State "├CURRENT┤"  from              [2025-10-08 Wed 23:01]
:END:

~M-x treesit-install-language-grammar~

NO:   https://github.com/tree-sitter/csharp-tree-sitter
YES?: https://github.com/tree-sitter/tree-sitter-c-sharp

mmmh... yay. -_-
#+begin_quote
⛔ Warning (treesit): The installed language grammar for csharp cannot be located or has problems (symbol-error): /home/main/.config/emacs/tree-sitter/libtree-sitter-csharp.so: undefined symbol: tree_sitter_csharp
#+end_quote

TODO: make csharp config file


* eval after

Find ~(when (imp-feature?~
example
  - [[file:source/user/config/help.el::;; TODO: change to eval-after:][here]]

Fix to eval after said feature.



* treesit: how can you do it in the init file?

prev treesits:
  - [[*fix: treesit & JSON][fix: treesit & JSON]]
  - [[*csharp & treesit?][csharp & treesit?]]

how to install grammers via elisp?
  - and how not to reinstall existing ones every time.

Is there some package already that helps?
  - like ~treesit-auto~ for Emacs 29
    - but I think that uses the ~tree-sitter~ package instead of the built in ~treesit~.

** do it in the init file for

...probably everything in the langs dir?
file:source/user/config/languages/
  - JSON


** decide between foo-ts and foo for org-src-lang-modes

[[file:source/user/config/org/mode.el::;; TODO: how to decide between `json' and `json-ts'?]]
#+begin_src elisp
  ;; TODO: how to decide between `json' and `json-ts'?
  ;; TODO: ...config var? `--/foo/bar/use-treesit'???
  (push '("json"                    . json-ts)    org-src-lang-modes)
#+end_src


* namespace

most wanted:
  1. path
  2. datetime
  3. buffer
  4. unit

* imp fixes

Make provide and require macros
  - find an example of what is wanted from this?

* snippet: notes directive

Fix these warnings in *Messages* during init?
#+begin_src txt
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/header
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/pass
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/quote
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src-insert
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src-yank
#+end_src


* snippet: /todo/penis

Make a snippet friendly TODO penis.
This one indents badly:

desired:/todo/penis
                             TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO.
TODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
ODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
DO TODO TODO TODO TODO TODO TODO TODO TODO'
O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

actual:/todo/penis
                             TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO.
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             ODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             DO TODO TODO TODO TODO TODO TODO TODO TODO'
                             O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

* treesitter
* elisp

Get settings and stuff.
Need my timestamp working.

* org

imp works* now.
Make org work now.

I wanna have a dir for it.
I wanna use imp. Debugging is a bit easier.
  - [[*imp][imp]]

Copy
  - from
    ~2023-07-23_sn004/mantle/config/org~
  - to
    ~2025-03-13_sn005/source/user/config/org~

Start editting for content:
  - [X] init.el
  - [X] mode.el
    - [X] [[*innit][you need some of innit]]
    - [X] [[file:source/user/config/org/theme/zenburn.el::;; TODO: Now I need some innit funcs...][you are here]]
    - [X] need org func lib thingy from sn004 too:
      - [X] [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/keyword.el][keyword.el]]
      - [X] [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/link.el][link.el]]

And then...
  - [ ] journal.el
  - [ ] pretty.el
  - [ ] version-control.el

Skip/avoid for now?
  - [ ] agenda.el
  - [ ] contacts.el
  - [ ] toggl.el


    
    
* "REFACTOR": namespaced

Need to refactor a buncha shite

Make a func that does all the function/var find & replace stuff?

M-x refactor-go-brrr


(defvar refactoring
  '(("imp:foo:bar/baz" . "imp-foo-bar-baz")
    ("imp:old:name" . "imp-name-something-different")
    ...)
  "alist of strings: (rx-to-find . replacement-str)")

Overall init file [[file:source/core/packages/namespaced/init.el][here]]
  - [ ] finish elisp/
  - [ ] finish str/
  - [ ] finish init/
  - [ ] start the rest...

* "REFACTOR": zenburn

Finish the zenburn refactor.

do
  - [ ] config/theme/zenburn/org.el
  - [ ] config/theme/zenburn/whitespace.el
  - [ ] config/theme/zenburn/init.el
    - partially done; finish

* repo buffernames

TODO groot or w/e for Project Rooted File Buffer Names (PRooFBuN)

* titlebar

* Secrets: 1Password CLI?

Is there a package for 1Password?
Should I use 1Password CLI instead of secret repo?

* imp improvements
** use-package integration via keyword

[[file:source/core/packages/imp/package.el::;; https://www.gnu.org/software/emacs/manual/html_node/use-package/Creating-an-extension.html][here]]

((use-package-ensure-elpa 'test-imp-up '(t) 'nil)
 (defvar use-package--warning10
   #'(lambda (keyword err)
       (let
           ((msg
             (format "%s/%s: %s" 'test-imp-up keyword
                     (error-message-string err))))
         (display-warning 'use-package msg :error))))
 (condition-case-unless-debug err
     (progn
       (condition-case-unless-debug err (message "init")
         (error (funcall use-package--warning10 :init err)))
       (if (not (require 'test-imp-up nil t))
           (display-warning 'use-package
                            (format "Cannot load %s" 'test-imp-up)
                            :error)
         (condition-case-unless-debug err (progn (message "config") t)
           (error (funcall use-package--warning10 :config err)))))
   (error (funcall use-package--warning10 :catch err))))


always imp?

from [[file:/usr/share/emacs/30.1/lisp/use-package/use-package-ensure.el.gz][use-package-ensure.el.gz]]
#begin_src emacs-lisp
(defcustom use-package-always-ensure nil
  "Treat every package as though it had specified using `:ensure SEXP'.
See also `use-package-defaults', which uses this value."
  :type 'sexp
  :group 'use-package-ensure
  :version "29.1")

(add-to-list 'use-package-defaults
             '(:ensure (list use-package-always-ensure)
                       (lambda (name args)
                         (and use-package-always-ensure
                              (not (plist-member args :load-path))))) t)
#end_src

(pp use-package-defaults)

use-package-defaults is alist of (keyword form-for-default-value form-for-whether-to-assign-default-value)

((:config '(t) t) (:init nil t)
 (:catch t (lambda (name args) (not use-package-expand-minimally)))
 (:defer use-package-always-defer
         (lambda (name args)
           (and use-package-always-defer
                (not (plist-member args :defer))
                (not (plist-member args :demand)))))
 (:demand use-package-always-demand
          (lambda (name args)
            (and use-package-always-demand
                 (not (plist-member args :defer))
                 (not (plist-member args :demand)))))
 (:ensure (list use-package-always-ensure)
          (lambda (name args)
            (and use-package-always-ensure
                 (not (plist-member args :load-path)))))
 (:pin use-package-always-pin use-package-always-pin))

** strip ~use-package~ down and make an argparser from it

;;------------------------------------------------------------------------------
;; Load Parsing Like Use-Package
;;------------------------------------------------------------------------------
;; `use-package' (macro)
;;   - `use-package-core' (macro)
;;     - `use-package-normalize-keywords'
;;       - `use-package-normalize-plist'
;;         - `use-package-normalize/:keyword'

;; (defun use-package-merge-keys (key new old)
;;   "Originally borrowed from `use-package-merge-keys'"
;;   (let ((merger (assq key use-package-merge-key-alist)))
;;     (if merger
;;         (funcall (cdr merger) new old)
;;       (append new old))))

;; (defun imp--load-normalize (name input &optional plist)
;;   "Given a pseudo-plist INPUT, normalize it to a regular plist.
;; The normalized key/value pairs from input are added to PLIST,
;; extending any keys already present.

;; Originally borrowed from `use-package-normalize-plist'"
;;   (if (null input)
;;       plist
;;     (let* ((keyword (car input))
;;            (xs (use-package-split-list #'keywordp (cdr input)))
;;            (args (car xs))
;;            (tail (cdr xs))
;;            (normalizer
;;             (intern-soft (concat "use-package-normalize/"
;;                                  (symbol-name keyword))))
;;            (arg (and (functionp normalizer)
;;                      (funcall normalizer name keyword args)))
;;            (error-string (format "Unrecognized keyword: %s" keyword)))
;;       (if (memq keyword use-package-keywords)
;;           (progn
;;             (setq plist (imp--load-normalize
;;                          name tail plist))
;;             (plist-put plist keyword
;;                        (if (plist-member plist keyword)
;;                            (funcall merge-function keyword arg
;;                                     (plist-get plist keyword))
;;                          arg)))
;;         (if use-package-ignore-unknown-keywords
;;             (progn
;;               (display-warning 'use-package error-string)
;;               (imp--load-normalize
;;                name tail plist))
;;           (use-package-error error-string))))))


** path: handle symlinks

e.g. in ~~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/init.org~
(let ((path-from-user (imp-path-current-dir-relative :user)))
  (imp:load :feature  '(:user config org mode)
            :path     path-from-user ;; (imp:path:current:dir/relative :user)
            :filename "mode"))
gets error:
Debugger entered--Lisp error: (error "[ERROR--]: imp-path-current-dir-relative:
Current directory is not relative to FEATURE/BASE!
FEATURE/BASE: :user
  root path:    /home/main/.config/emacs/source/user/
  curr path:    /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/
---> result:    /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/")

It gets this because emacs loaded via symlink:
ll ~/.config/emacs
lrwxrwxrwx 1 main main 53 Mar 14 15:30 /home/main/.config/emacs -> /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/

So it thinks those paths are different when actually they're the same after following the symlink.

** imp-path-root-set

*** no error msg on repeat calls

working on [[file:source/core/packages/namespaced/str/init.el][ns/str/init.el]] and calling `eval-buffer' to see if the errors are gone yet.

So this gets called each time:
(imp-path-root-set :str
                   (imp-path-current-dir)
                   (imp-file-current))

Don't want the _same exact_ call to trigger the error message:
  > apply: [ERROR--]: imp-path-root-set: FEATURE-BASE ’:str’ is already an imp root.

*** defaults

I do this a lot in init files:

(imp-path-root-set :str
                   (imp-path-current-dir)
                   (imp-file-current))

Make those the defaults?
(imp-path-root-set :str)
                   
** imp-timing default file/path

90+% I just want current dir/file:

(imp-timing
    :elisp
    (imp-file-current)
    (imp-path:current:dir)
  ...)

Can I make them optional?
(imp-timing
    :elisp
  ...)

maybe like `dolist'?
(imp-timing (:elisp)  ...)  
(imp-timing (:elisp ?path ?file)  ...)  


Or split into two?

(imp-timing
    :elisp
  ...)

(imp-timing-also
    :elisp
    path
    file
  ...)
    
** imp-load default filename

Want to be able to just do this:

(imp-path-root-set :user
                   (imp-path-join user-emacs-directory 'source 'user))
(imp-load :feature '(:user config org))

instead of this:

(imp-path-root-set :user
                   (imp-path-join user-emacs-directory 'source 'user))
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'config 'org))

Can do just this I think?:
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'source 'user 'config 'org))

Want to be able to do like:
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'source 'user 'config 'org))
(imp-load :feature '(:user config foo))
(imp-load :feature '(:user config bar))
(imp-load :feature '(:user baz))
** ??? Add to places in imp/path.el

`convert-standard-filename' for canonicalizing filenames/fielpaths.
(expand-file-name (convert-standard-filename "etc/") user-emacs-directory)
  - https://github.com/emacscollective/no-littering/blob/ea15b1c607d4036ce37326bd5b4b2f4291ddfd60/no-littering.el#L92C3-L92C77

** ??? refactor funcs

imp--load-parse
  - make error checking funcs?
  - make bool flag parsing func

** ??? when I get to tests

https://emacs.stackexchange.com/a/17202


* zenburn: high contrast mode?

Can I make ~hc-zenburn~ piggyback on top of ~zenburn~?
  - Probably not... The colors are probably all hand-picked.
    - But ~hc-zenburn~ does have a script to mess with brightness.
      - https://github.com/edran/hc-zenburn-emacs/blob/master/change_brightness.py
    - And I have funcs to mess with colors: 
      - [[file:source/core/packages/innit/face.el::defun innit:color:darken (color alpha &optional colors-alist][here]] or [[file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/keyword.el][sn004]]
        
TODO: Make ~zenburn-high-contrast~ for ~zenburn~ somehow.



