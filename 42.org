[[file:source/user/template.el::;;; user/config/TODO-FILENAME.el --- TODO-SHORT-DESCRIPTION -*- lexical-binding: t; -*-][template.el]]
GOTO [[here][U R HERE]]

* ├DONE───┤ .emacs.d layout
CLOSED: [2025-06-03 Tue 22:33]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

source/user/config
  - dev-env?
  - devops?
  - languages
  - keybinds?
  - org

** old


├── core
│   ├── boot
│   │   ├── 00-early
│   │   ├── 10-init
│   │   ├── 20-config
│   │   └── 99-finalize
│   └── modules
│       ├── elisp
│       │   ├── datetime
│       │   ├── jerky
│       │   │   └── test
│       │   └── utils
│       ├── emacs
│       │   ├── alist
│       │   │   ├── test
│       │   │   │   └── type
│       │   │   └── type
│       │   ├── buffer
│       │   ├── chrome
│       │   ├── dlv
│       │   │   └── test
│       │   ├── imp
│       │   │   └── test
│       │   │       └── loading
│       │   ├── innit
│       │   ├── path
│       │   ├── str
│       │   └── template
│       ├── output
│       │   └── nub
│       │       └── test
│       └── system
│           ├── multiplexer
│           └── secret
├── mantle
│   ├── config
│   │   ├── dev-env
│   │   │   └── languages
│   │   ├── hydra
│   │   ├── keybinds
│   │   └── org
│   ├── init
│   │   └── keybinds
│   │       └── general
│   └── theme
│       └── zenburn
├── modules
│   ├── dev-env
│   │   └── taskspace
│   ├── emacs
│   │   ├── persp+
│   │   └── perspective
│   ├── input
│   ├── mode
│   │   └── org
│   └── tools
│       └── signature


** snippets

├── snippets
│   ├── emacs-lisp-mode
│   ├── fundamental-mode
│   ├── gitconfig-mode
│   ├── org-mode
│   ├── prog-mode
│   ├── python-mode
│   ├── sh-mode
│   └── yaml-mode

* ├DONE───┤ imp
CLOSED: [2025-06-03 Tue 22:33]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

** refactor symbol names

get
  - [X] copy paste imp to this .emacs

init.el [[file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/init.el]]

first
  - [-] rename functions
    - [X] int<imp> -> imp--
    - [ ] : -> /

ChatGPT?
  - process-file already exists... oops.

#+begin_src elisp
  (require 'cl-lib)

  ;; imp:provide:with-emacs
  ;; imp:path:root/set
  ;; int<imp>:load:parse
  ;;
  ;; ...oh wait test functions...
  ;; ...those ones got wild...
  ;; test<imp/load>::helper::int<imp>:load:parse
  (defun _refactor-buffer-00 (namespace)
    "[DONE] more normal func/var names."
    (let* ((regex (rx-to-string
                   `(and
                     (or
                      (and "int<"
                           ,namespace
                           ">")
                      ,namespace)
                     ":"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))

      (goto-char (point-min))

      (while (re-search-forward regex nil t)
        (replace-match (concat namespace
                               (if (string-prefix-p "int<" (match-string 0))
                                   "--" ; private
                                 "/") ; public
                               (replace-regexp-in-string "[/:]" "-" (match-string 1)))))))

  (defun _refactor-buffer-01 (namespace)
    "[DONE] even normaler func/var names"
    (let* ((regex (rx-to-string
                   `(and
                     (group
                      (not "/")
                      ,namespace)
                     "/"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))

      (goto-char (point-min))

      (while (re-search-forward regex nil t)
        (replace-match (concat (match-string 1)
                               "-"
                               (match-string 2))))))
  ;; (_refactor-shit "imp" "source/core/packages/imp/error.el")

  (defun _refactor-file (namespace file)
    "Process a single FILE for NAMESPACE refactoring."
    (let* ((existing-buffer (find-buffer-visiting file))
           (regex (rx-to-string
                   `(and
                     (or
                      (and "int<"
                           ,namespace
                           ">")
                      ,namespace)
                     ":"
                     (group (+ (any alnum ":" "/"))))
                   'no-group)))
      (save-window-excursion
        (save-mark-and-excursion
          (if existing-buffer
              (switch-to-buffer existing-buffer)
            (find-file file))
          (goto-char (point-min))

          ;;(_refactor-buffer-00 namespace)
          (_refactor-buffer-01 namespace)

          (save-buffer)
          (unless existing-buffer
            (kill-buffer))))))

  (defun _refactor-directory (namespace dir)
    "Process all *.el files in DIR recursively for refactoring."
    (dolist (file (directory-files-recursively dir "\\.el$"))
      (_refactor-file namespace file)))

  (defun _refactor-shit (namespace path)
    "Prompt the user for a PATH and refactor namespace patterns within it."
    (interactive "GPath to file or directory: ")
    (if (not (file-exists-p path))
        (error "The path does not exist!")
      (if (file-directory-p path)
          (_refactor-directory namespace path)
        (_refactor-file namespace path))))

  ;; [FILE]  (_refactor-shit "imp" "source/core/packages/imp/init.el")
  ;; [ALL] (_refactor-shit "imp" "source/core/packages/imp")
  ;;
  ;; [TODO] (_refactor-shit "imp" "source/core/packages/imp/error.el")
#+end_src

debug...
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k
  - [X] k

test on:
  - [X] ~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/init.el

run on:
  - [X] ~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp

save script off somewhere for the next thing...
  - [X] [[file:scripts/refactor-sn4-to-sn5.el]]

** imp/provide/with-emacs

Make ~imp/provide~ act like ~imp/provide/with-emacs~ by default.
  - flag param to not ~with-emacs~ it.

DONE

** go through files in order

and do what?

check for includes and non-halal shit

files:
  - [X] error.el
  - [X] debug.el
  - [X] alist.el
    - feature uses this, so shouldn't it be before it?
      - Let's find out...
  - [X] tree.el
    - feature uses this, so shouldn't it be before it?
      - Let's find out...
  - [X] feature.el
  - [X] path.el
  - [X] flag.el
  - [X] timing.el
  - [X] provide
  - [X] load
  - [X] require
  - [X] package
  - [X] commands

** load a file

(imp-load :feature '(:test)
          :filename "test.el"
          :optional t)

see [[file:init.el::;; (setq imp--debugging? t)][here]] for trying to get imp load working

Debugger entered--Lisp error: (error "[ERROR     ]: imp-load: Feature is still not defined after loading the file!\n  feature:       (:quote test)\n  path:          \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/test.el\"\n  ‘load’-result: t")

Am I going round in circles?
Seen this about 3 times?

Debugger entered--Lisp error: (error "[ERROR-----]: imp--tree-contains: CHAIN is not a chain: :test")
  signal(error ("[ERROR-----]: imp--tree-contains: CHAIN is not a chain: :test"))
  error("[ERROR-----]: imp--tree-contains: CHAIN is not a chain: %S" :test)
  apply(error "[ERROR-----]: imp--tree-contains: CHAIN is not a chain: %S" :test)
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  ...
  imp--tree-contains?(:test ((:test) (:imp (require) (load) (provide))))
  (null (imp--tree-contains? (imp-feature-normalize features) imp-features))
  (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features)))
  (progn (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features))))
  (if imp-features (progn (not (null (imp--tree-contains? (imp-feature-normalize features) imp-features)))))
  imp-feature-exists?(((:test)))
  (or (imp-feature-exists? feature) (featurep (imp-feature-normalize-for-emacs feature)))
  imp-provided?((:test))

(imp-feature-normalize '((:test)))

(imp--tree-contains? (imp--feature-normalize '((:test))) imp-features)

ok. it was
this:    (imp-feature-normalize :test)
vs this: (imp--feature-normalize :test)


;; (setq imp--debugging? t)
;; (imp-load :feature '(:test) :path "source/user" :filename "test.el")
;; imp-features
;; features
;; (imp-provided? :test)
;; (imp--unprovide-from-emacs :test)

test.el load work!

** unprovide

(setq imp--tree-debug-flag t)

not fully tested but here we be.

DONE

** again, check for unused funcs and shit

test.el: do the refactoring; missed this file
  - [ ] k
    - Meh

search for what to get all?
rg '^\(def(un|var|const|custom) ' .
rg '^\(def[a-z]* ' .


TODO
TODO
TODO
TODO
TODO
Check [9/17]
  - [X] source/core/packages/imp/init.el
    - [X] 61   (defgroup imp nil

  - [X] source/core/packages/imp/fundamental.el
    - [X] 34   (defun imp--string-or-nil (whatever)
    - [X] 44   (defun imp--string-empty? (str &optional trim?)
    - [X] 63   (defun imp--unquote (arg)

  - [X] source/core/packages/imp/output.el
    - [X] 30   (defcustom imp-output-buffer "ⓘ-imp-output-ⓘ"
    - [X] 36   (defcustom imp-output-level
    - [X] 61   (defun imp--output-callers (callers)
    - [X] 90   (defun imp--output-level-get (level setting)
    - [X] 98   (defun imp--output-prefix (level)
    - [X] 131  (defun imp--output-sink (message &rest args)
    - [X] 150  (defun imp--output (level caller string args)

  - [X] source/core/packages/imp/error.el
    - [X] 30   (defun imp--error (caller string &rest args)
    - [X] 51   (defun imp--error-if (error? caller string &rest args)
    - [X] 71   (defun imp--error-user (caller string &rest args)
      - [X] Delete.

  - [X] source/core/packages/imp/debug.el
    - [X] 40   (defvar imp--debugging? nil
    - [X] 44   (defun imp-debug (enabled?)
      - [X] delete
    - [X] 52   (defun imp-debug-toggle ()
    - [X] 61   (defun imp-debug-status (&optional msg)
    - [X] 105  (defun imp--debug (caller string &rest args)
    - [X] 122  (defun imp--debug-newline ()
    - [X] 136  (defun imp--debug-init ()

  - [X] source/core/packages/imp/alist.el
    - [X] 26   (defun imp--list-flatten (input)
    - [X] 55   (defun imp--alist-key-valid (caller key &optional error?)
    - [X] 73   (defun imp--alist-get-value (key alist &optional equal-fn)
    - [X] 83   (defun imp--alist-get-pair (key alist &optional equal-fn)
    - [X] 92   (defun imp--alist-update-helper (key value alist &optional equal-fn)
    - [X] 118  (defmacro imp--alist-update (key value alist &optional equal-fn)
    - [X] 147  (defun imp--alist-delete-helper (key alist &optional equal-fn)
    - [X] 164  (defmacro imp--alist-delete (key alist &optional equal-fn)

  - [X] source/core/packages/imp/tree.el
    - [X] 31   (defvar imp--tree-debug-flag nil
    - [X] 35   (defun imp--tree-debug (caller string &rest args)
    - [X] 48   (defun imp--tree-node? (node)
    - [X] 68   (defun imp--tree-tree? (tree)
    - [X] 97   (defun imp--tree-chain? (chain &optional rooted)
    - [X] 131  (defun imp--tree-key-exists? (key tree)
    - [X] 143  (defun imp--tree-chain (chain value)
    - [X] 182  (defun imp--tree-create (chain value)
    - [X] 188  (defun imp--tree-branch-update (entry branch)
    - [X] 221  (defun imp--tree-update-helper (chain value tree)
    - [X] 362  (defmacro imp--tree-update (chain value tree)
    - [X] 390  (defun imp--tree-contains? (chain tree)
    - [X] 436  (defun imp--tree-delete-helper (chain tree)
    - [X] 539  (defmacro imp--tree-delete (chain tree)
    - [X] 593  (defun imp--tree-map (function chain-reversed tree &optional dbg-depth)
    - [X] 675  (defun imp--tree-chains-get-all (chain-reversed tree)

  - [X] source/core/packages/imp/feature.el
    - [X] 36   (defvar imp-features nil
    - [X] 79   (defvar imp-features-locate nil
    - [X] 95   (defconst imp--features-locate-equal #'equal
    - [X] 106  (defun imp-feature-exists? (features)
    - [X] 117  (defun imp-feature? (&rest feature)
    - [X] 126  (defun imp-mode? (mode)
    - [X] 136  (defun imp--feature-count (&optional tree)
    - [X] 152  (defun imp-feature-count ()
    - [X] 164  (defconst imp--feature-replace-rx
    - [X] 190  (defconst imp--feature-replace-separator
    - [X] 198  (defun imp--feature-normalize-name (name)
    - [X] 220  (defun imp--feature-normalize-chain (&rest chain)
    - [X] 255  (defun imp--feature-normalize-to-list (&rest chain)
    - [X] 300  (defun imp-feature-normalize-for-emacs (&rest feature)
    - [X] 324  (defun imp-feature-normalize-for-imp (&rest input)
    - [X] 360  (defun imp-feature-normalize-for-display (&rest feature)
    - [X] 385  (defun imp--feature-add (normalized)
    - [X] 412  (defun imp--feature-get-tree (normalized)
    - [X] 417  (defun imp--feature-delete (normalized)
    - [X] 426  (defun imp-feature-assert (&rest feature)
    - [X] 446  (defun imp--feature-locations (feature-root)
    - [X] 452  (defun imp--feature-paths (&rest feature)
    - [X] 526  (defun imp-feature-at (feature-root feature-alist)

  - [X] source/core/packages/imp/path.el
    - [X] 39   (defconst imp--path-replace-rx
    - [X] 165  (defvar imp-path-roots nil
    - [X] 174  (defconst imp-path-filename-init "imp-init.el"
    - [X] 178  (defconst imp-path-filename-features "imp-features.el"
    - [X] 186  (defun imp-path-canonical (path &optional root)
    - [X] 194  (defun imp-path-join-canonical (&rest path)
    - [X] 210  (defun imp-path-abbreviate (&rest path)
    - [X] 218  (defun imp--path-relative (feature-or-root path &optional error?)
    - [X] 317  (defun imp-path-relative (feature-or-root &rest path)
    - [X] 348  (defun imp--path-root-dir (feature-base &optional no-error?)
    - [X] 366  (defun imp--path-file-exists? (root &rest paths)
    - [X] 383  (defun imp--path-strings? (root &rest paths)
    - [X] 391  (defun imp--path-root-file-init (feature-base &optional no-exist-check)
    - [X] 440  (defun imp--path-root-file-features (feature-base &optional no-exist-check)
    - [X] 474  (defun imp--path-root-contains? (feature-base)
    - [X] 479  (defun imp--path-root-valid? (caller path &rest kwargs)
    - [X] 569  (defun imp--path-safe-string (symbol-or-string)
    - [X] 614  (defun imp--path-safe-list (feature)
    - [X] 628  (defun imp--path-dir? (path)
    - [X] 639  (defun imp-path-parent (path)
    - [X] 671  (defun imp--path-filename (path)
    - [X] 681  (defun imp-path-current-file ()
    - [X] 708  (defun imp-path-current-file-relative (&optional feature-or-root)
    - [X] 742  (defun imp-file-current ()
    - [X] 747  (defun imp-path-current-dir ()
    - [X] 754  (defun imp-path-current-dir-relative (feature/base)
    - [X] 818  (defvar imp--path-path-platform-case-insensitive
    - [X] 826  (defun imp--path-platform-agnostic (path)
    - [X] 849  (defun imp--path-to-str (input)
    - [X] 884  (defun imp--path-append (parent next)
    - [X] 912  (defun imp-path-join (&rest path)
    - [X] 927  (defun imp--path-sans-extension (&rest path)
    - [X] 937  (defun imp--path-canonical (root relative &optional assert-exists sans-extension)
    - [X] 1085 (defun imp-path-root-set (feature-base path-dir-root &optional path-file-init path-file-features)
    - [X] 1128 (defun imp-path-root-get (feature-base &optional no-error?)
    - [X] 1148 (defun imp--path-init ()

  - [ ] source/core/packages/imp/flag.el
    - [ ] 33   (defvar imp--feature-flags nil
    - [ ] 56   (defun imp--flag-split (flag)
    - [ ] 93   (defun imp--flag-compare (flag-a flag-b)
    - [ ] 130  (defun imp--flag-exists? (feature flag)
    - [ ] 157  (defmacro imp-flag? (feature flag)
    - [ ] 187  (defmacro imp-flag (feature &rest flag)

  - [ ] source/core/packages/imp/timing.el
    - [ ] 46   (defcustom imp-timing-enabled? nil
    - [ ] 52   (defcustom imp-timing-buffer-tail? t
    - [ ] 59   (defconst imp-timing-feature? (imp-flag? :imp +timing)
    - [ ] 63   (defun imp-timing-enabled? ()
    - [ ] 77   (defconst imp-timing-format-tree
    - [ ] 92   (defconst imp--timing-precision 4
    - [ ] 96   (defvar imp--timing-indent 0
    - [ ] 106  (defvar imp--timing-feature-current nil
    - [ ] 115  (defvar imp-timing-sum 0.0
    - [ ] 123  (defcustom imp-timing-buffer-name
    - [ ] 135  (defcustom imp-timing-buffer-show t
    - [ ] 141  (defcustom imp-timing-format-load "loading %1$S..."
    - [ ] 153  (defcustom imp-timing-format-skip "skip: %1$S"
    - [ ] 165  (defcustom imp-timing-reason "reason: "
    - [ ] 179  (defcustom imp-timing-format-skip-already-provided "feature already provided"
    - [ ] 191  (defcustom imp-timing-format-skip-optional-dne "optional file does not exist: %3$s"
    - [ ] 203  (defcustom imp-timing-format-time-total
    - [ ] 240  (defcustom imp-timing-format-time
    - [ ] 255  (defcustom imp-timing-separator-restart
    - [ ] 264  (defcustom imp-timing-separator-final
    - [ ] 277  (defun imp--timing-feature-duplicate? (feature)
    - [ ] 293  (defun imp--timing-tree-type (type indent)
    - [ ] 323  (defun imp--timing-tree-string (type)
    - [ ] 336  (defun imp--timing-buffer-messages? ()
    - [ ] 352  (defun imp-timing-buffer-name ()
    - [ ] 361  (defun imp--timing-buffer-get (&optional buffer-or-name &rest args)
    - [ ] 391  (defun imp--timing-buffer-tail ()
    - [ ] 415  (defun imp--timing-buffer-show (force-show?)
    - [ ] 424  (defun imp-cmd-timing-buffer-bury (&optional ignore-messages-buffer)
    - [ ] 443  (defun imp-cmd-timing-buffer-kill (&optional ignore-messages-buffer)
    - [ ] 466  (defun imp--timing-buffer-insert (string)
    - [ ] 519  (defun imp--timing-message (type formatting &rest args)
    - [ ] 529  (defun imp--timing-start (feature filename path)
    - [ ] 540  (defun imp--timing-end (time:start)
    - [ ] 553  (defun imp-timing-skip-already-provided (feature filename path)
    - [ ] 575  (defun imp-timing-skip-optional-dne (feature filename path)
    - [ ] 597  (defmacro imp-timing (feature filename path &rest body)
    - [ ] 646  (defun imp-timing-restart ()
    - [ ] 672  (defun imp--timing-final (&optional separator-line?)
    - [ ] 687  (defun imp--timing-final-timer (&optional separator-line?)
    - [ ] 707  (defun imp-timing-final (&optional separator-line?)
    - [ ] 726  (defun imp--timing-mode-font-lock-keywords-element-create (matcher subexp facename &optional override laxmatch)
    - [ ] 777  (defconst imp--timing-mode-font-lock-keywords
    - [ ] 972  (defconst imp--timing-mode-font-lock-defaults
    - [ ] 1018 (defvar imp-timing-mode-map

  - [ ] source/core/packages/imp/provide.el
    - [ ] 52   (defalias 'imp-provided? 'imp-feature?)
    - [ ] 53   (defalias 'imp-providedp 'imp-feature?)
    - [ ] 56   (defun imp-provide-to-imp (&rest feature)
    - [ ] 86   (defun imp-provide-to-emacs (&rest feature)
    - [ ] 107  (defun imp-provide (&rest feature)
    - [ ] 128  (defun imp--unprovide-feature-from-emacs (&rest feature)
    - [ ] 142  (defun imp--unprovide-tree-from-emacs (normalized tree)
    - [ ] 149  (defun imp-unprovide (&rest feature)

  - [ ] source/core/packages/imp/load.el
    - [ ] 33   (defun imp--load-file (filepath)
    - [ ] 62   (defun imp--load-paths (feature path-root paths-relative)
    - [ ] 106  (defun imp--load-feature (&rest feature)
    - [ ] 271  (defun imp--load-parse (caller path-current-dir plist-symbol-name plist)
    - [ ] 525  (defmacro imp-load (&rest load-args-plist)

  - [ ] source/core/packages/imp/require.el
    - [ ] 33   (defun imp-require (&rest feature)

  - [ ] source/core/packages/imp/package.el
    - [ ] 102  (defmacro imp-use-package (name &rest args)
    - [ ] 138  (defmacro imp-eval-after (feature &rest body)

  - [ ] source/core/packages/imp/commands.el
    - [ ] 31   (defcustom imp-output-features-buffer
    - [ ] 42   (defun imp-cmd-features-print ()
    - [ ] 53   (defun imp-cmd-features-nuke ()


also check for ones to declare in like
  (declare (pure t)
           (side-effect-free t)
           (important-return-value t))

got bored.
ok.
moving on...

** settings.el

move all defcustoms to settings.el
load settings first(?)

** imp-load bugs

Do minimum now.
Do better after emacs is more than limping along.



Macro can't deal with funcs properly:
  (imp-load :feature '(:user config org)
            :path (imp-path-join 'user 'config 'org)
            )

Debugger entered--Lisp error: (wrong-type-argument stringp (imp-path-join 'user 'config 'org))
  expand-file-name((imp-path-join 'user 'config 'org) "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
  (setq out-path (expand-file-name in-filename in-path))


Probably not a bug??:
  (imp-load :feature '(:user config org)
            :path  "user/config/org"
            )


Debugger entered--Lisp error: (file-missing "Cannot open load file" "No such file or directory" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/user/config/org")
  load("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/user/config/org" nil nomessage)

I think moving that one call out in front of macro expansion was probably bad for short term stability.

Uh.....
I think this requires more than minimum to fix....

So the minimum is... fix the callers?

* ├DONE───┤ file timestamp auto-update
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-06-03 Tue 22:38]
- State "├CURRENT┤"  from "├DONE───┤"  [2025-06-03 Tue 22:37]
- State "├DONE───┤"  from              [2025-06-03 Tue 22:33]
:END:

mantle/config/dev-env/languages/emacs-lisp.el
163     (emacs-lisp-mode-hook . mantle:hook:time-stamp:settings)

[[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el]]

[[file:init.el::;; PRIORITY: Everything: Emacs Settings]]
;; TODO: More from: file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el
;; (add-hook 'before-save-hook 'time-stamp)



* ├DONE───┤ disable some annoying keybinds
CLOSED: [2025-06-03 Tue 22:34]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:34]
:END:

new funcs?
  keymap-unset
  keymap-global-unset

Disable C-z
Disable C-mousewheel (font size +/-)


* ├DONE───┤ switch to zenburn
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:38]
:END:

~hc-zenburn-theme~ is unmaintained.

Move from ~hc-zenburn-theme~ back to ~zenburn-theme~.


* ├DONE───┤ innit
CLOSED: [2025-06-03 Tue 22:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:38]
:END:

Need the face funcs.
So start porting.

~/ocean/vault/.config/emacs/2023-07-23_sn004/core/modules/emacs/innit

steal funcs from sn004 or steal all namespaced libs?
 - Turns out: first the one, then the other.

Just the face funcs for now:
file:~/ocean/vault/.config/emacs/2023-07-23_sn004/core/modules/emacs/innit/theme.el

Need:
  - [X] ns:str
    - ~str:normalize:join~
  - [X] ns:list
    - ~elisp:list:listify~ -> ~list:to-list~?

back to the face funcs:
[[file:source/core/packages/namespaced/theme/face.el]]

Annnd... it loads!

hm....
Do I even want to keep this Doomism?
Just convert to the Emacs version and just call the Emacs funcs?
Keep Doom->Emacs func but make others work on the converted?

meh. As-is works for Doom and[or Emacs face specs.

What the hell was I doing all this for?
  - oh right; org-mode todo keywords. Go [[*org][here]].

* ├DONE───┤ zenburn & org
CLOSED: [2025-06-03 Tue 22:39]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-03 Tue 22:39]
:END:

old zen+org: [[file:source/user/config/theme/zenburn/org-mode.el][here]]
new zen+org: [[file:source/user/config/org/theme/zenburn.el][here]]

Get my zenburn fixes for org-mode in.

~mode:org:todo/keyword~ is what now?

Where'd I put this func again???
mode:org:todo/keywords

rg '(mode)?.*org.*todo.*keyword'
find -name link.el
find -name keyword.el

mmh... nowhere, looks like.

copied:
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/init.el
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/keyword.el
  - file:/home/main/ocean/vault/.config/emacs/sn005/source/user/mode/org/link.el

Need:
  - ~buffer:region:get~
  - :buffer 'delete
k

Where was I?..
back to new zen+org: [[file:source/user/config/org/theme/zenburn.el][here]]
  - k

...and then?
everything done?

* ├DONE───┤ completion
CLOSED: [2025-06-04 Wed 16:27]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-06-04 Wed 16:27]
:END:

corfu, vertico, etc

get from sn-004
  - k

[[file:source/user/config/completion.el]]



* ├DONE───┤ yasnippets
CLOSED: [2025-09-09 Tue 23:50]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:50]
- State "├CURRENT┤"  from              [2025-09-09 Tue 22:34]
:END:

** ├DONE───┤ 004's snippets
CLOSED: [2025-09-09 Tue 22:34]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-09 Tue 22:34]
:END:

Need my begin_src snippet...
#+begin_src bash
cd /home/main/ocean/vault/.config/emacs/2023-07-23_sn004
cp -r snippets ../2025-03-13_sn005/
#+end_src

** ├DONE───┤ use package
CLOSED: [2025-09-09 Tue 23:41]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:41]
- State "├CURRENT┤"  from              [2025-09-09 Tue 22:37]
:END:

Where is it in 004?
#+begin_src console
2023-07-23_sn004 on  main [!?]
❯ rg "use-package.*yas"
mantle/config/dev-env/snippets.el
111:(imp:use-package yasnippet
574:(imp:use-package yasnippet
636:(imp:use-package yasnippet
#+end_src

file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/dev-env/snippets.el

test:

#+begin_src yaml
foo:
  bar:
    - baz
    - qux
#+end_src




** ├DONE───┤ new snippets
CLOSED: [2025-09-09 Tue 23:48]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-09 Tue 23:48]
- State "├CURRENT┤"  from              [2025-09-09 Tue 23:41]
:END:

/todo/penis
                             TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO.
TODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
ODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
DO TODO TODO TODO TODO TODO TODO TODO TODO'
O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

/todo/penis
                             TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO.
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             ODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             DO TODO TODO TODO TODO TODO TODO TODO TODO'
                             O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO
meh.
hm...
back to drawing board...


* ├DONE───┤ line/column
CLOSED: [2025-09-11 Thu 22:10]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-11 Thu 22:10]
:END:

old sn004: file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/emacs.el
new sn005: file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/emacs.el


* ├DONE───┤ FIX: timestamps
CLOSED: [2025-09-12 Fri 14:38]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-12 Fri 14:38]
:END:

...timestamps stopped working???
[[file:init.el::;; (Automatic) Time Stamps]]

oh. they never started working.
I need my elisp mode config so elisp files start timestamping.
  - well it works but...
...timestamps remain unchanging.

time-stamp-start
  - org-mode hook runs time-stamp settings hook
  - elisp does not

--/hook/time-stamp/settings
--/hook/time-stamp/before-save

ok. it wasn't this it was other stuff.
errors and bad hooks in elisp mode

* ├DONE───┤ recentf
CLOSED: [2025-09-22 Mon 13:18]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-22 Mon 13:18]
- State "├CURRENT┤"  from              [2025-09-22 Mon 12:00]
:END:

sn004 config:
file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/files.el

sn005:
[[file:source/user/config/files.el]]

* ├DONE───┤ ns/unit
CLOSED: [2025-09-22 Mon 15:17]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-22 Mon 15:17]
:END:
* ├DONE───┤ ns/datetime
CLOSED: [2025-09-22 Mon 16:37]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-22 Mon 16:37]
:END:

* ├DONE───┤ elisp mode config
CLOSED: [2025-09-23 Tue 23:04]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-23 Tue 23:04]
- State "├CURRENT┤"  from "├DONE───┤"  [2025-09-12 Fri 14:29]
- State "├DONE───┤"  from              [2025-09-12 Fri 14:15]
:END:

these have weird complaints when evaluating right now
  - [[file:source/user/config/languages/elisp.el::(use-package highlight-quoted]]
  - [[file:source/user/config/languages/elisp.el::use-package macrostep]]

+Ok. Restarted Emacs and init for those works fine now.+
load of elisp.el was not added to init.

** ├DONE───┤ Errors
CLOSED: [2025-09-23 Tue 22:19]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-23 Tue 22:19]
:END:

Get these errors:
#+begin_src warnings
⛔ Error (use-package): Cannot load macrostep
⛔ Error (use-package): Cannot load elisp-demos
#+end_src

https://github.com/jwiegley/use-package/issues/768
use this to debug?:
#+begin_src elisp
(setq use-package-verbose t
            use-package-expand-minimally nil
            use-package-compute-statistics t
            debug-on-error t)

(defun use-package-require (name &optional no-require body)
  (if use-package-expand-minimally
      (use-package-concat
       (unless no-require
         (list (use-package-load-name name)))
       body)
    (if no-require
        body
      (use-package-with-elapsed-timer
          (format "Loading package %s" name)
        `((if (not ,(use-package-load-name name))
              (display-warning 'use-package
                               (format "Cannot load %s" ',name)
                               :error)
            ,@body))))))

(use-package macrostep)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (file-missing "Cannot open load file" "No such file or directory" "macrostep")
  require(macrostep nil nil)
  (not (require 'macrostep nil nil))
  (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t))
  (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract (current-time) now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))
  (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract (current-time) now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep")))))
  (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time (time-subtract ... now)))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t))
  (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require 'macrostep nil nil)) (display-warning 'use-package (format "Cannot load %s" 'macrostep) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed (float-time ...))) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err)))
  (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let ((msg (format "%s/%s: %s" ... keyword ...))) (display-warning 'use-package msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not (require ... nil nil)) (display-warning 'use-package (format "Cannot load %s" ...) :error) (use-package-statistics-gather :config 'macrostep nil) (use-package-statistics-gather :config 'macrostep t)) (let ((elapsed ...)) (if (> elapsed 0) (message "%s...done (%.3fs)" "Loading package macrostep" elapsed) (message "%s...done" "Loading package macrostep"))))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t))
  (progn (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let ((msg ...)) (display-warning 'use-package msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now (current-time))) (message "%s..." "Loading package macrostep") (prog1 (if (not ...) (display-warning ... ... :error) (use-package-statistics-gather :config ... nil) (use-package-statistics-gather :config ... t)) (let (...) (if ... ... ...)))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t)))
  eval((progn (progn (use-package-statistics-gather :use-package 'macrostep nil) (use-package-ensure-elpa 'macrostep '(t) 'nil) (defvar use-package--warning50 #'(lambda (keyword err) (let (...) (display-warning ... msg :error)))) (condition-case err (progn (use-package-statistics-gather :init 'macrostep nil) (let ((now ...)) (message "%s..." "Loading package macrostep") (prog1 (if ... ... ... ...) (let ... ...))) (use-package-statistics-gather :init 'macrostep t)) ((debug error) (funcall use-package--warning50 :catch err))) (use-package-statistics-gather :use-package 'macrostep t))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x8fa3722e129a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x8fa3722e129a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

so..... it didn't install the package?

maybe I need melpa at front of list instead of back?
  nope

maybe I need to delete a bad install?

restart emacs to clean up package stuff?
  - that worked. ~use-package macrostep~ worked; ~macrostep~ is installed.

Uncomment ~elisp-demos~ & eval
  - k; good

** ├DONE───┤ Hooks
CLOSED: [2025-09-23 Tue 23:04]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-09-23 Tue 23:04]
:END:

And I guess these need fixed too:
(remove-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode)
(remove-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)

* ├DONE───┤ whitespace
CLOSED: [2025-09-24 Wed 14:07]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-09-24 Wed 14:07]
- State "├CURRENT┤"  from              [2025-09-09 Tue 23:55]
:END:

cleanup
butler
visuals
etc

old sn004: [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/whitespace.el]]
new sn005: file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/whitespace.el

get theme fixes for whitespace mode
[[file:source/user/config/theme/zenburn/whitespace.el]]

* ├DONE───┤ org eval src blocks: shells
CLOSED: [2025-10-08 Wed 21:57]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-08 Wed 21:57]
- State "├CURRENT┤"  from              [2025-10-08 Wed 21:50]
:END:

Want to be able to eval bash...

InternGPT says:
#+begin_quote
To enable evaluating source blocks for Bash in Emacs Lisp when using Org-mode,
you need to ensure that the =ob-shell= package is loaded or required, and the
language is included in the list of supported languages for evaluation. You can
achieve this by adding the following code to your Emacs configuration:

#+begin_src lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t))) ; Enable evaluation for shell scripts (including bash)
#+end_src

Make sure Org-mode is installed and configured in your Emacs setup. After adding
this code, you can evaluate shell source blocks within Org-mode documents. Note
that it's important to be cautious and understand the security implications of
executing code blocks.
#+end_quote

#+begin_src bash
ls
#+end_src

#+RESULTS:
| 42.org         |
| auto-save-list |
| early-init.el  |
| eln-cache      |
| elpa           |
| etc            |
| init.el        |
| LICENSE        |
| scripts        |
| snippets       |
| source         |
| symlink.sh     |
| var            |

yay

* ├DONE───┤ fix: treesit & JSON
CLOSED: [2025-10-08 Wed 22:25]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:25]
:END:

** ├DONE───┤ install tree-sitter grammar
CLOSED: [2025-10-08 Wed 22:32]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:32]
:END:

#+begin_quote
⛔ Warning (treesit): Cannot activate tree-sitter, because language grammar for json is unavailable (not-found): /home/main/.config/emacs/tree-sitter/libtree-sitter-json: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.14.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.13.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.0.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.14.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.13.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.0: cannot open shared object file: No such file or directory /home/main/.config/emacs/tree-sitter/libtree-sitter-json.so.0.0: cannot open shared object file: No such file or directory libtree-sitter-json: cannot open shared object file: No such file or directory libtree-sitter-json.14.0: cannot open shared object file: No such file or directory libtree-sitter-json.13.0: cannot open shared object file: No such file or directory libtree-sitter-json.0: cannot open shared object file: No such file or directory libtree-sitter-json.0.0: cannot open shared object file: No such file or directory libtree-sitter-json.so: cannot open shared object file: No such file or directory libtree-sitter-json.so.14.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.13.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.0: cannot open shared object file: No such file or directory libtree-sitter-json.so.0.0: cannot open shared object file: No such file or directory
#+end_quote

google:
Cannot activate tree-sitter, because language grammar for json is unavailable (not-found)

https://www.masteringemacs.org/article/how-to-get-started-tree-sitter
~M-x treesit-install-language-grammar~

So... do that thing then.

** ├DONE───┤ use treesit when viewing JSON
CLOSED: [2025-10-08 Wed 22:49]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:49]
:END:

So... now am I using treesit when I open JSON file?
  - no. I'm using ~js-json-mode~ instead of ~json-ts-mode~.

Need a JSON config file.
  - old one? file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/dev-env/languages/json.el

make:
file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/languages/json.el

** ├DONE───┤ Get json highlights working in src blocks
CLOSED: [2025-10-08 Wed 22:51]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-08 Wed 22:51]
:END:

#+begin_src json
{
    "test": true,
    "greeting": "Hello there."
}
#+end_src

fix in [[file:source/user/config/org/mode.el::push '("json" . json-ts) org-src-lang-modes][org/mode.el]]
#+begin_src elisp
  (push '("json"                    . json-ts)    org-src-lang-modes)
#+end_src



* ├DONE───┤ helpful & which-key
CLOSED: [2025-10-09 Thu 14:29]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-09 Thu 14:29]
- State "├CURRENT┤"  from              [2025-10-09 Thu 14:25]
:END:

old: file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/mantle/config/help.el
make:
file:~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/help.el


* ├DONE───┤ gptel: GPT 5?
CLOSED: [2025-10-10 Fri 15:42]
:LOGBOOK:
- State "├DONE───┤"  from "├SUCCESS┤"  [2025-10-10 Fri 15:42]
- State "├SUCCESS┤"  from "├CURRENT┤"  [2025-10-10 Fri 15:42]
- State "├CURRENT┤"  from              [2025-10-10 Fri 14:32]
:END:

move config to ~source/user/config/ai.el~

update from 4o to 5
  - [[file:source/user/config/ai.el::gptel-model 'gpt-5][here]]

* ├DONE───┤ macrostep-expand broken?
CLOSED: [2025-10-24 Fri 00:04]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-24 Fri 00:04]
:END:

#+begin_src elisp
(defmacro m-test ()
  (message "Hello there!")
  (range-map (apply-partially #'format "%S")
             '((0 . 100000)))
  (message "General Kenobi!"))
;; m-x macrostep-expand this:
(m-test)
#+end_src

IDFK. It hasn't been updated in 2 years.
Delete it?

deleted it.

* ├DONE───┤ IMP-FIX: imp-load
CLOSED: [2025-10-24 Fri 00:06]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-24 Fri 00:06]
- State "├CURRENT┤"  from              [2025-09-25 Thu 15:44]
:END:

After restarting emacs & returning to this branch:
#+begin_src elisp
;; reload imp to get new code.
(load (expand-file-name "source/core/packages/imp/init.el" user-emacs-directory))
(imp-path-root-set 'imp "~/.config/emacs/source/core/packages/imp/")
#+end_src

** ├DONE───┤ use-package parser
CLOSED: [2025-10-16 Thu 16:37]
:PROPERTIES:
:ORDERED:  t
:END:
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 16:37]
- State "├CURRENT┤"  from              [2025-09-25 Thu 15:44]
:END:

Make load parse its args like use-package does?
  - ur [[file:source/core/packages/imp/parser.el::provide 'use-package-core][here]]
    - Refactor that to be useful to imp.

Mmh...
(setq imp-parser-verbose 'debug)
then see how it goes?


(setq imp-parser-verbose nil)
(setq imp-parser-verbose 'errors)
(setq imp-parser-verbose 'debug)
(imp-parser foo)
(imp-parser foo :optional t)
(imp-parser foo :optional t :error t)

(imp-parser foo :path (imp-path-current-dir))

And then:
  - [X] make defaults [[file:source/core/packages/imp/parser.el::(defcustom imp-parser-defaults][here]]
  - [ ] Make bare minimum work:
    - (imp-parser foo)
      - load from PWD or load-paths?
    - (imp-parser :user test)
      - load test from :user root?
      - Should I change to something like (imp-parser user/test)?

So... I need the handlers to call the load func once they're all done?
So... ~imp-parser-process-keywords~ needs the logic.
  - [[file:source/core/packages/imp/parser.el::;; TODO: (if (null plist)][imp-parser-process-keywords]]
  - [[file:source/core/packages/imp/parser.el::defun imp-parser-load (name state][imp-parser-load]]

(setq imp-parser-verbose nil)
(setq imp-parser-verbose 'debug)
(imp-parser foo)
(imp-parser foo :optional t)
(imp-parser foo :optional t :error t)

Make path normalizer more dumb?
  - Make the defaults an ordered list?
  - Make people use ":/" or ~FOO:/blah~ or ~(from-)feature(-root)~ for feature-rooted paths?
  - Make people use "./" or ~pwd~ for ~imp-path-current-dir~?
  - Maybe get it down to the only guess being ~user-emacs-directory~?

Check path normalizer/handler.

(imp-parser-normalize/:path :user/foo :path '(nil))
(imp-parser-normalize/:path :user/foo :path '(root))
(imp-parser-normalize/:path :user/foo :path '(.emacs.d))
(imp-parser-normalize/:path :user/foo :path '(cwd))

k

maybe I should try an actually bound symbol?
(imp-parser-normalize-path :user :path 'user-emacs-directory)
(imp-parser-normalize/:path :user/foo :path '(user-emacs-directory))
Yay. It follows its symlink.

Make file that can be loaded many times.
  - w/ just a message or something in it.
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el


Refactor ~imp/feature.el~ for new style features.
  - [[file:source/core/packages/imp/feature.el][here]]
look for ~TODO-HERE~
  - [X] k

#+begin_src elisp
;; TODO-HERE: Which is a rooted feature?
;; :root/first/second
;; root:/first/second
#+end_src
  - [[file:source/core/packages/imp/feature.el::;; TODO-HERE: Which is a rooted feature?][here]]
  - [X] k

Honestly I should be on an imp branch...
  - [X] k

ok
I think I have all the `imp-feature` things I need now.

Fix default path w/ feature root:
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
(imp-parser '(imp test data/load manual-test))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  file-name-nondirectory(nil)
  imp--path-filename(nil)
  (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-to-list name))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load path (not (or ... ...)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))
  (let* ((funcname "imp-parser-load") (path (plist-get state :path))) (if imp--debugging? (progn (imp--debug funcname "load '%s'" path-load))) (let ((imp--macro-feature (imp--feature-normalize-to-list name))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-filename (imp--path-filename path)) (imp--macro-path (imp-path-parent path)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-filename imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (load path (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load path (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))))
  imp-parser-load(imp:/test/data/load/manual-test nil)
...
#+end_src

Hmmm... I need a normalizer and handler for NAME/FEATURE in imp-parser.

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
(imp-parser (imp test data/load manual-test))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument listp t)
  cdr(t)
  macroexp-progn(t)
  (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))
  (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*)))))
...
#+end_src

Now I need to return a form so the macro works.

and then?
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

...imp-timing macro is sad.
make one that returns forms instead of evals them?
or do I have one?

How do I debug the macro expansion anyways?
  - ~macrostep~ doesn't work.

How 'bout this?
#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing 'imp:/test/data/load/manual-test "manual-test"
:              "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
:    (load
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))

need to eval all the state gets.
  - k

#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing 'imp:/test/data/load/manual-test "manual-test"
:              "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
:    (load
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (not (or nil nil)) 'nomessage)))

...imp-timing macro is probably still sad.
make one that returns forms instead of evals them
  - ~imp-timing-core~?
    - [[file:source/core/packages/imp/timing.el::defmacro imp-timing-core (feature filename path &rest body][yeah]]
Make that thing work.
And only take a path.
[[file:source/core/packages/imp/timing.el::defmacro imp-timing-core (feature filename path &rest body][yeah]] go here.

#+begin_src elisp
(imp-timing-core 'imp:/test/data/load/manual-test/1
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
    (message "Hello there."))
#+end_src

that might work maybe?

#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
: ((imp-timing-core 'imp:/test/data/load/manual-test
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      (load
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:       (not (or nil nil)) 'nomessage)))

Maybe. Try it.

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (invalid-function (let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  (progn ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "name" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))))
  eval((progn ((let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'quote/name) (imp--timing-start 'quote/name "name") (prog1 (let ((imp--timing-indent ...)) (load "name" (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x480b065b629a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x480b065b629a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src


#+begin_src elisp
(pp-to-string (imp-parser-load 'imp:/test/data/load/manual-test nil))
#+end_src

#+RESULTS:
#+begin_example elisp
((let ((imp--macro-time (current-time)))
   (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
   (imp--timing-start 'imp:/test/data/load/manual-test
                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
   (prog1
       (let ((imp--timing-indent (1+ imp--timing-indent)))
         (load
          "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
          (not (or nil nil)) 'nomessage))
     (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
#+end_example

That looks right, right?


#+begin_src elisp
(imp-parser-debug imp:/test/data/load/manual-test nil)
#+end_src

#+RESULTS:
#+begin_example elisp
((let ((imp--macro-time (current-time)))
   (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
   (imp--timing-start 'imp:/test/data/load/manual-test
                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
   (prog1
       (let ((imp--timing-indent (1+ imp--timing-indent)))
         (load
          "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
          (not (or nil nil)) 'nomessage))
     (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
#+end_example

Also looks right, right?

#+begin_src elisp
(macroexpand (imp-parser imp:/test/data/load/manual-test))
#+end_src

Annd... I got:
#+begin_quote
loading name...
└─00.0057 seconds
#+end_quote

#+begin_src elisp
(imp-parser-handler/:requires 'foo :requires '(bar) nil nil)
#+end_src
hm....

#+begin_src elisp
(macroexpand (imp-parser imp:/test/data/load/manual-test))
#+end_src

#+begin_src elisp
(pp-to-string (imp-timing-core imp:/test/data/load/manual-test/1
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
    (message "Hello there.")))
#+end_src
better maybe?

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (void-variable let)
  (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (progn (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))))
  eval((progn (progn let ((imp--macro-time (current-time))) (setq imp--timing-feature-current 'feature) (imp--timing-start 'feature "feature") (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "feature" (not (or nil nil)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0x480b065b629a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0x480b065b629a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

nope.

SIIIIIGH
I wish I knew how to expand macros one step at a time....

#+begin_src elisp
(pp-to-string
 (macroexp-progn
  (imp-parser-concat
   (imp-parser-core imp:/test/data/load/manual-test nil))))
#+end_src

#+RESULTS:
#+begin_example elisp
(let ((imp--macro-time (current-time)))
  (setq imp--timing-feature-current 'imp:/test/data/load/manual-test)
  (imp--timing-start 'imp:/test/data/load/manual-test
                     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test")
  (prog1
      (let ((imp--timing-indent (1+ imp--timing-indent)))
        (load
         "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
         (not (or nil nil)) 'nomessage))
    (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
#+end_example

Hmm.... ~load.el~ won't load right now.
#+begin_src elisp
(load (expand-file-name "source/core/packages/imp/load.el" user-emacs-directory))
#+end_src

That fails because of ~imp--load-paths~
~imp--load-paths~ because of ~imp-timing~
~imp-timing~ still had a ~filename~ var; deleted.

#+begin_src elisp
(load (expand-file-name "source/core/packages/imp/load.el" user-emacs-directory))
#+end_src
yay

so imp-parser-core works
Why doesn't imp-parser work? :(
I broke use-package's parser :((

restart & reload...
  - that always fixes things. :fingers-crossed:

#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src

ok. This is better than last night.
#+begin_src backtrace
Debugger entered--Lisp error: (void-variable state)
  (plist-get state :error)
  (or (plist-get state :error) (plist-get state :optional))
  (not (or (plist-get state :error) (plist-get state :optional)))
  (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)
  (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))
  (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or ... ...)) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))
  (progn (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not ...) 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage))))
  eval((progn (let ((imp--macro-feature (imp--feature-normalize-chain 'imp/test/data/load/manual-test))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "manual-test") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let (...) "imp/test/data/load" (load "imp/test/data/load/manual-test" ... ...)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) "imp/test/data/load" (load "imp/test/data/load/manual-test" (not (or (plist-get state :error) (plist-get state :optional))) 'nomessage)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

Oh. It works-ish?
#+begin_src elisp
(imp-parser imp:/test/data/load/manual-test)
#+end_src
Didn't get any timing this time, but:

#+begin_quote
Loading ’manual-test.el’ for 0 time...
t
#+end_quote
I loaded it for the first time.
  - yay.
I got back a ~t~ return value.
  - yay.

With timing this time tho?

Oh; this is how macroexpand works. You gotta quote it.
#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser imp:/test/data/load/manual-test))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test "manual-test" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))

Oh. this still has filename & dir path.
Need just filepath.
#+begin_src elisp
(imp-timing 'imp:/test/data/load/manual-test
    "manual-test"
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load"
(load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))
#+end_src

#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser imp:/test/data/load/manual-test))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test" (not (or nil nil)) 'nomessage))

Oh. I'm not using ~imp-timing-core~.
:thinking:
If it works, use it?

#+begin_src elisp
(macroexpand-1
 (imp-timing 'imp:/test/data/load/manual-test
     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
     (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
           (not (or nil nil))
           'nomessage)))
#+end_src

#+RESULTS:
: t

Aw... Still no timing message.
Is timing enabled?
oh; clear current feature.
#+begin_src
imp--timing-feature-current
(setq imp--timing-feature-current nil)
#+end_src

#+begin_src elisp
(imp-timing 'imp:/test/data/load/manual-test
     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
     (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
           (not (or nil nil))
           'nomessage))
#+end_src

#+RESULTS:
: t

yay. got timing message.
#+begin_quote
loading imp:/test/data/load/manual-test...
└─00.0075 seconds
#+end_quote

And then....?
  - [X] commit
  - [ ] test with args

I think that counts as
  - [X] Make bare minimum work

and this headline is long
TO THE NEXT HEADLINE!

** ├DONE───┤ imp-parser keywords: ~optional~, ~error~
CLOSED: [2025-10-16 Thu 17:21]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 17:21]
- State "├CURRENT┤"  from              [2025-10-16 Thu 16:41]
:END:

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test :optional t :error t)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      (not (or :error :optional)) 'nomessage))

Ok, so the args show up in the macro output.

optional file that DNE:
#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test :optional t :error nil)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      'noerror 'nomessage))

Add defaults for:
  -  ~:error~; should be true.
  -  ~:optional~; should be false.

and this should have a nil for ~noerror~ param
#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/manual-test)))
#+end_src

#+RESULTS:
: (imp-timing 'imp:/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      nil 'nomessage))

yay

so this should error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist)
#+end_src

it did.

and this should not error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

#+RESULTS:

it did not error.
  - yay

also this should not error
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :error nil)
#+end_src

#+RESULTS:

it did not error.
  - yay

However, imp-timing doesn't know about whether optionals exist or not.

** ├DONE───┤ more info about optional files
CLOSED: [2025-10-16 Thu 20:29]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-16 Thu 20:29]
- State "├CURRENT┤"  from              [2025-10-16 Thu 17:23]
:END:

We should get "optional file dne; skipping" info in the imp-timing buffer for this:
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

~imp-load~ does it like so:
#+begin_src elisp
;;---
;; Optional?
;;---
;; Skip if optional and file doesn't exist.
((and imp--macro-optional?
      (not (file-exists-p imp--macro-path-file)))
 ;; Skip w/ optional timing message.
 (imp-timing-skip-optional-dne imp--macro-feature
                               imp--macro-name-load
                               imp--macro-path-file)
 (setq imp--macro-load-file? nil)
 ;; Return nil for 'did not load'.
 (setq imp--macro-load-result nil))
#+end_src
  - [[file:source/core/packages/imp/load.el::;; Optional?][here]]

make imp-path-has-load-extension work
  - k

fix imp-path-load-file to work if path already has ext
  - k

#+begin_src elisp
(imp-path-load-file "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test")
(imp-path-load-file "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test.el")
(imp-path-has-load-extension "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test")
(imp-path-has-load-extension "~/.config/emacs/source/core/packages/imp/test/data/load/manual-test.el")
#+end_src

hokay...
use those somewhere...
~imp-parser-load~

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/does-not-exist :optional t)))
#+end_src

#+RESULTS:
: (progn
:   (imp-timing-skip-optional-dne 'imp:/test/data/load/does-not-exist
:                                 "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist")
:   nil)


#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist :optional t)
#+end_src

#+begin_quote
skip: imp:/test/data/load/does-not-exist
│ └─reason: optional file does not exist: /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist
#+end_quote

** ├DONE───┤ imp-parser keyword: ~:path~
CLOSED: [2025-10-16 Thu 21:27]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-16 Thu 21:27]
:END:

So this works.
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser imp:/test/data/load/does-not-exist)
#+end_src

Will this work?
Can't remember if it assumes ~user-emacs-directory~ if it has nothing.
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test)
#+end_src

Nope. It has no path so it assumes nothing.
#+begin_quote
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-load:
Cannot find a file to load.
path:’source/core/packages/imp/test/data/load/manual-test’ -> load-path:’nil’")
#+end_quote

er... now the warnings buffer says
#+begin_quote
⛔ Error (imp-parser): Failed to parse package source/core/packages/imp/test/data/load/manual-test: Wrong type argument: stringp, nil
#+end_quote

Oh. That's the condition case that catches the error.
...do I even want to catch that error?
  - No. Lose top level ~condition-case~
    - k

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string (macroexpand-1 (imp-parser source/core/packages/imp/test/data/load/manual-test)))
#+end_src

#+begin_quote
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  file-name-absolute-p(nil)
#+end_quote

the new check is doin' it.
  - fixed

add a path
#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test
  :path .emacs)
#+end_src

#+begin_quote
Debugger entered--Lisp error: (error "[ERROR--]:
imp-parser-load: Cannot find a file to load.
path:’/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test’
 -> load-path:’nil’")
#+end_quote

That should be the path...?
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el
yeah, that's the file.

So why is path-load nil?

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser source/core/packages/imp/test/data/load/manual-test
    :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-timing 'source/core/packages/imp/test/data/load/manual-test
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:       (imp--error 'imp-parser-load
:                   "Cannot find a file to load. path:'%s' -> load-path:'%s'"
:                   "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:                   nil))
:   nil)

hmm... sus.
#+begin_src elisp
    (message "path: %S" path)
    (message "load: %S "(imp-path-load-file path))

    ;; Convert path to a load path.
    (let (path-load (imp-path-load-file path))

      (message "path: %S" path)
      (message "path-load: %S " path-load)
      (message "load: %S " (imp-path-load-file path))
#+end_src

#+begin_quote
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
load: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
path-load: nil
load: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
#+end_quote

oh. Not enough parens.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser source/core/packages/imp/test/data/load/manual-test
    :path .emacs)))
#+end_src

#+RESULTS:
: (imp-timing 'source/core/packages/imp/test/data/load/manual-test
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:     (load
:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:      'nil 'nomessage))

k.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(imp-parser source/core/packages/imp/test/data/load/manual-test
  :path user-emacs-directory)
#+end_src
  - works

Good enough for now.


** ├DONE───┤ imp-parser keyword: ~:root~?
CLOSED: [2025-10-20 Mon 21:38]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-20 Mon 21:38]
- State "├CURRENT┤"  from              [2025-10-16 Thu 21:55]
:END:

Allow adding a dir as a feature's root.

so this should add to ~imp-path-roots~:
#+begin_src elisp
(setq imp--timing-feature-current nil)
;; TODO: delete from root paths
(imp-parser imp:/test/data/load/does-not-exist
  :optional t
  :root 'itdl
)
#+end_src

expect ~(itdl "~/.config/emacs/source/core/packages/imp/test/data/load/" nil)~ in:
#+begin_src elisp
(pp-to-string imp-path-roots)
#+end_src

I need to do a thing after load.
  - which will probably mess up how load works, since it assumes it's last.
Add a secret keyword for "load happens here in the turn order"?

And I need the full real actual path so I can make the root.
  - So load will need to put that in the plist when its done?

Or I need to get the full real actual path during path handling.

move code in
  - [[file:source/core/packages/imp/parser.el::;; Figure out path from FEATURE?][imp-parser-load]]
to
  - [[file:source/core/packages/imp/parser.el::;; Add (some of) FEATURE to end of path?][imp-parser-normalize/:path]]

Make ~:path~ default to nil so we always run the path normalization.
Make ~:path~ handler also put load path into ~state~.

Add ~:root~ to the vars
  - [[file:source/core/packages/imp/parser.el::(defcustom imp-parser-keywords][imp-parser-keywords]]
    - Put a comment in there for where the loading should happen.
  - +[[file:source/core/packages/imp/parser.el::(defcustom imp-parser-defaults][imp-parser-defaults]]+
    - Don't wanna do anything if keyword doesn't exist, so don't have a default.

(imp-parser-normalize/:path :user/foo :path '(user-emacs-directory))

(imp-feature-normalize 'test)

#+begin_src elisp
(let ((name 'test/foo/bar)
      (keyword :root)
      (args '(t))
      ;;(args '(test))
      (rest nil)
      (state (list :path (imp-path-current-dir))))
  (imp-parser-normalize/:root name keyword args))
  (imp-parser-handler/:root name keyword (car args) rest state))
#+end_src

Hokay.

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]
kk

~:root~ as flag.
#+begin_src elisp
(imp-parser-only-one
 "hello"
 '("test");(imp-parser-normalize-flag :_ nil)
 #'imp-parser-normalize-symbol-or-string)
#+end_src

#+begin_src elisp
(let ((name 'test/foo/bar)
      (keyword :root)
      args
      ;;(args '(t))
      ;;(args '(test))
      (rest nil)
      (state (list :path (imp-path-current-dir))))
  (imp-parser-normalize/:root name keyword args))
#+end_src
  - k

TEST!

#+begin_src elisp
(pp-to-string imp-path-roots)
#+end_src

#+RESULTS:
#+begin_example
((imp "~/.config/emacs/source/core/packages/imp/" nil)
 (:theme
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme"
  "init.el" nil)
 (:str
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str"
  "init.el" nil)
 (:datetime
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime"
  "init.el" nil)
 (:unit
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit"
  "init.el" nil)
 (:buffer
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer"
  "init.el" nil)
 (:elisp
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp"
  "init.el" nil)
 (:user "~/.config/emacs/source/user" nil nil)
 (:emacs.d "~/.config/emacs/" nil nil)
 (:imp "/home/main/.config/emacs/source/core/packages/imp" "init.el" nil))
#+end_example

#+begin_src elisp :results scalar
(macroexpand-1 '(imp-parser temp/init
                  :root
                  :path .emacs))
#+end_src

#+RESULTS:
: (progn (imp-path-root-set 'temp "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp") (imp-timing 'temp/init "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init" (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init" 'nil 'nomessage)))

yay?

#+begin_src elisp :results scalar
(list :result (imp-parser temp/init
              :root
              :path .emacs)
      :roots imp-path-roots)
#+end_src

ok.
butt.....
Need to allow dupes in `imp-path-root-set'.

Hm... why was the first set right but now it wants the parent of what it should have?
#+begin_quote
existing: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp"
new:      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005"
e == n ?  nil
#+end_quote

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
:   (imp-timing 'temp:/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init" 'nil
:             'nomessage)))

Maybe because root exists, and roots don't add to their path....
So they should and get deduped?

Commit as is

debug with clean slate

hm... maybe get this working again?
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/does-not-exist
     :optional t)))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  locate-file-internal(nil ("/") (".so" ".so.gz" ".elc" ".elc.gz" ".el" ".el.gz") nil)
  locate-file(nil ("/") (".so" ".so.gz" ".elc" ".elc.gz" ".el" ".el.gz"))
  imp-path-load-file(nil)
  (imp-parser-plist-maybe-put state :path-load (imp-path-load-file arg))
  (setq state (imp-parser-plist-maybe-put state :path-load (imp-path-load-file arg)))
  imp-parser-handler/:path(imp:/test/data/load/does-not-exist :path nil (:error t :optional t) nil)
  funcall(imp-parser-handler/:path imp:/test/data/load/does-not-exist :path nil (:error t :optional t) nil)
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(imp:/test/data/load/does-not-exist (:path nil :error t :optional t))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(imp:/test/data/load/does-not-exist :optional t)
  apply(#f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* ...) (args* ...) (imp-parser--form ...)) (if (eq imp-parser-verbose ...) (progn ... ... ... ...)) (imp-parser-process-keywords name* args*)))))) (imp:/test/data/load/does-not-exist :optional t))
  macroexpand-1((imp-parser imp:/test/data/load/does-not-exist :optional t))
  (pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/does-not-exist :optional t)))
  (progn (pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/does-not-exist :optional t))))
  eval((progn (pp-to-string (macroexpand-1 '(imp-parser imp:/test/data/load/does-not-exist :optional t)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

Hmmm....
this works but that just has nil for path???
#+begin_src elisp
(imp-parser-normalize/:path 'imp:/test/data/load/does-not-exist :path nil)
#+end_src

#+begin_quote
arg: nil
ipnpa: nil
path: nil
feature-root: imp
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist"
"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist"
#+end_quote

#+begin_src elisp
(imp-parser imp:/test/data/load/does-not-exist
  :optional t)
#+end_src

Why is it not using normalizer???
#+begin_quote
Wrote /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/42.org
handler-arg:nil
Entering debugger...
#+end_quote

oh. Default values are not normalized.
[[file:source/core/packages/imp/parser.el::(setq args (imp-parser-normalize-plist name-symbol args nil][here]]
-_-

mmmmh.....
Oh. We can put a form/function in that gets eval'd for default value.

#+begin_src elisp
(defun test-default-path (feature _)
  (imp-parser-normalize/:path feature :path nil))

(defcustom imp-parser-defaults
  '(;; (KEYWORD DEFAULT-VALUE USAGE-PREDICATE)
    (:path     test-default-path t)
#+end_src

#+begin_src elisp
(imp-parser imp:/test/data/load/does-not-exist
  :optional t)
#+end_src
It has ~:path~ now... but ~:path-load~ is still nil?

#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-load: Path is invalid or not absolute! path-load:’nil’")
  signal(error ("[ERROR--]: imp-parser-load: Path is invalid or not absolute! path-load:’nil’"))
  error("[ERROR--]: imp-parser-load: Path is invalid or not absolute! path-load:'%s'" nil)
  apply(error "[ERROR--]: imp-parser-load: Path is invalid or not absolute! path-load:'%s'" nil)
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error imp-parser-load ("Path is invalid or not absolute! " "path-load:'%s'") (nil))
  imp--error(imp-parser-load ("Path is invalid or not absolute! " "path-load:'%s'") nil)
  (if (and (stringp path-load) (file-name-absolute-p path-load)) nil (imp--error funcname '("Path is invalid or not absolute! " "path-load:'%s'") path-load))
  (let* ((funcname 'imp-parser-load) (path (plist-get state :path)) (path-load (plist-get state :path-load)) (feature-root (imp-feature-root feature))) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname '("Path is invalid or not absolute! " "path:'%s'") path)) (if (and (stringp path-load) (file-name-absolute-p path-load)) nil (imp--error funcname '("Path is invalid or not absolute! " "path-load:'%s'") path-load)) (if (null path-load) (if (plist-get state :optional) (list (cons 'progn (cons (list 'imp-timing-skip-optional-dne (list ... feature) path) '(nil)))) (imp--error funcname "Cannot find a file to load. path:'%s' -> load-path:'%s'" path path-load)) (if imp--debugging? (progn (imp--debug funcname "load '%s' => '%s'" path path-load))) (list (list 'imp-timing (list 'quote feature) path-load (cons 'load (cons path (cons (list ... ...) '...)))))))
  imp-parser-load(imp:/test/data/load/does-not-exist (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(imp:/test/data/load/does-not-exist nil (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  imp-parser-handler/:optional(imp:/test/data/load/does-not-exist :optional t nil (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  funcall(imp-parser-handler/:optional imp:/test/data/load/does-not-exist :optional t nil (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(imp:/test/data/load/does-not-exist (:optional t) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  imp-parser-handler/:error(imp:/test/data/load/does-not-exist :error t (:optional t) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  funcall(imp-parser-handler/:error imp:/test/data/load/does-not-exist :error t (:optional t) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(imp:/test/data/load/does-not-exist (:error t :optional t) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :path-load nil :error t :optional t))
  imp-parser-handler/:path(imp:/test/data/load/does-not-exist :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" (:error t :optional t) nil)
  funcall(imp-parser-handler/:path imp:/test/data/load/does-not-exist :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" (:error t :optional t) nil)
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(imp:/test/data/load/does-not-exist (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist" :error t :optional t))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(imp:/test/data/load/does-not-exist :optional t)
  macroexpand((imp-parser imp:/test/data/load/does-not-exist :optional t))
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

#+begin_quote
arg: nil
ipnpa: nil
path: nil
feature-root: imp
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist"
handler-arg:"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist"
#+end_quote

What's this guy's problem?
#+begin_src elisp
(imp-path-load-file "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist")
#+end_src

....where the fuck is this guy?
  - oh. ~;; TODO: MOVE TO path.el~
    - [[file:source/core/packages/imp/parser.el::defun imp-path-load-file (path-absolute][here]]

#+begin_src elisp
(let ((path-absolute "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist"))
  (locate-file path-absolute
               '("/") ; Don't use `load-paths'; we have an absolute path.
               (get-load-suffixes)))
#+end_src

oh; right; duh.
does not exist
so nil load path is correct.

So does this work now?
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/does-not-exist
     :optional t)))
#+end_src

#+RESULTS:
: (progn
:   (imp-timing-skip-optional-dne 'imp:/test/data/load/does-not-exist
:                                 "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/does-not-exist")
:   nil)

yay.

Where were we?
Testing ~:root~?
Oh. Debugging why path changes when re-running:
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
:   (imp-timing 'temp:/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init.el"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init" 'nil
:             'nomessage)))

Cuz the first time, that path was correct:
#+begin_src elisp
(imp-path-root-get 'temp :no-error)
#+end_src

#+RESULTS:
: /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp

...Is the path correct the first time now?
Make a func to delete a root first.
  - [X] k
  - [X] use it to delete ~temp~ root

go again:
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+begin_quote
arg: (\.emacs)
ipnpa: (\.emacs)
ipnpa: \.emacs
ipnpa: "~/.config/emacs/"
path: ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
feature-root: nil
path: "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init"
test-default-path: hello
arg: nil
ipnpa: nil
path: nil
feature-root: nil
apply: [ERROR--]: imp-parser-normalize/:path: ‘:path’ should end up as absolute: got: ’nil’ -> ’nil’
#+end_quote

??????
But it has a ~:path~ value. Why is it running the default value function???
do I need a predicate?
It just runs the defaults and then only inserts the results if it needs to.
So predicate it or never error.
So predicate for now?
  - k

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp")
:   (imp-timing 'temp/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init.el"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init"
:             'nil 'nomessage)))

See, this is good.
But if root already exists...

#+begin_src elisp
(imp-path-root-set 'temp
                   "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp")
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
     :root
     :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005")
:   (imp-timing 'temp:/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init.el"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/init" 'nil
:             'nomessage)))

It does wrong file now?!

Oh; cuz it still has ~:path .emacs~
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init)))
;;     :root
;;     :path .emacs)))
#+end_src

#+RESULTS:
: (imp-timing 'temp:/init
:     "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init.el"
:     (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init" 'nil
:           'nomessage))

Yah... hm...

What /do/ you do when you have a root with a path and then also a path?
Figure it out the same way you did the first time.

could be the problem?
#+begin_src elisp
    ;; Add rest of NAME to path; is a relative path.
    (setq path (apply #'imp-path-join
                      path
                      ;; FEATURE, sans root. eg `imp:/parser' -> `parser'
                      (imp-feature-unrooted feature)))
#+end_src
  - [[file:source/core/packages/imp/parser.el::(setq path (apply #'imp-path-join][here]]

#+begin_src elisp
(imp-path-root-get 'temp :no-error)
#+end_src

#+begin_src elisp
(imp-parser-normalize/:path 'temp:/init :path '(emacs))
#+end_src

#+RESULTS:
: /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init

yay

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser temp/init
    :root
    :path .emacs)))
#+end_src

#+RESULTS:
: (progn
:   (imp-path-root-set 'temp
:                      "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp")
:   (imp-timing 'temp:/init
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init.el"
:       (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/temp/init"
:             'nil 'nomessage)))

kay.

** ├DONE───┤ imp-parser keyword: ~:timing~
CLOSED: [2025-10-21 Tue 14:53]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-21 Tue 14:53]
:END:

nil
t
"don't show buffer"

Should this be ~timing~ though?
  - maybe ~load-tree~
  - just ~tree~?
  - ~display~?

:display nil
:display t / tree
:display autoshow

:timing nil
:timing t / tree
:timing autoshow

IDFK. Leave as timing for now.

Change buffer name to be "*imp*"?
  - [X] yes

make funcs
  - [X] normalizer
  - [ ] handler

#+begin_src elisp
(imp-parser-normalize/:timing 'testing :timing nil)
(imp-parser-normalize/:timing 'testing :timing '(t))
(imp-parser-normalize/:timing 'testing :timing '(autoshow))
(imp-parser-normalize/:timing 'testing :timing '("hello"))
#+end_src

...can't actually do real timing in handler?
because file can be missing and that's a different thing altogether
So.... just... stuff it into the state?
[[file:source/core/packages/imp/parser.el::defun imp-parser-handler/:timing (name keyword arg rest state][here]]

Should this be ~timing~ though?
  - What about ~stats~ / ~statistics~?
:stats nil
:stats t / timing
:stats debug
:stats autoshow
:stats debug autoshow
:stats (debug autoshow)

Alright, fine. ~stats~.

implement stat flags:
  - [X] t / default
  - [ ] timing
  - [ ] autoshow
  - [ ] debug

Ok; this is more work than I want right here/now.
  - Moved to [[*imp statistics][imp statistics]]

** ├DONE───┤ imp-parser keywords: ~:if~ ~:when~ ~:unless~
CLOSED: [2025-10-21 Tue 14:59]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-21 Tue 14:59]
- State "├CURRENT┤"  from              [2025-10-21 Tue 14:54]
:END:

Implementation from ~use-package~.

Test.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(setq test-toggle (when (boundp test-toggle) (not test-toggle)))
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/manual-test
     :unless test-toggle)))
#+end_src

#+RESULTS:
: (when (not test-toggle)
:   (imp-timing 'imp:/test/data/load/manual-test
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:       (load
:        "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:        'nil 'nomessage)))

Hokay.

oh. Merging.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(setq test-toggle (when (boundp test-toggle) (not test-toggle)))
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/manual-test
     :unless test-toggle
     :if foo)))
#+end_src

#+RESULTS:
: (when (and (symbol-value 'foo) (not test-toggle))
:   (imp-timing 'imp:/test/data/load/manual-test
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:       (load
:        "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:        'nil 'nomessage)))

** ├DONE───┤ imp-parser keyword: ~:requires~
CLOSED: [2025-10-21 Tue 15:07]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-21 Tue 15:07]
- State "├CURRENT┤"  from              [2025-10-21 Tue 15:06]
:END:

Implementation from ~use-package~.

Test.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/manual-test
     :requires foo)))
#+end_src

#+RESULTS:
: (when (featurep 'foo)
:   (imp-timing 'imp:/test/data/load/manual-test
:       "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:       (load
:        "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:        'nil 'nomessage)))

** ├DONE───┤ imp-parser keyword: ~:after~
CLOSED: [2025-10-21 Tue 15:10]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-21 Tue 15:10]
:END:

Implementation from ~use-package~.

Test.

#+begin_src elisp
(setq imp--timing-feature-current nil)
(setq test-toggle (when (boundp test-toggle) (not test-toggle)))
(pp-to-string
 (macroexpand-1
  '(imp-parser imp:/test/data/load/manual-test
     :after foo
     :after bar)))
#+end_src

#+RESULTS:
: (eval-after-load 'bar
:   '(eval-after-load 'foo
:      '(imp-timing 'imp:/test/data/load/manual-test
:           "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test.el"
:           (load
:            "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp/test/data/load/manual-test"
:            'nil 'nomessage))))

** ├DONE───┤ imp-parser: unquote NAME
CLOSED: [2025-10-21 Tue 15:40]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-21 Tue 15:40]
- State "├CURRENT┤"  from              [2025-10-21 Tue 15:13]
:END:

#+begin_src elisp
;;------------------------------
;;;; NAME
;;------------------------------

(defun imp-parser-normalize-name (name)
  ;; TODO: make this func unqoute NAME?
  (imp-feature-normalize name)) ; TODO: or this func?
#+end_src
  - [[file:source/core/packages/imp/parser.el::defun imp-parser-normalize-name (name][here]]

#+begin_src elisp
(setq imp--timing-feature-current nil)
(pp-to-string
 (macroexpand-1
  '(imp-parser 'imp:/test/data/load/manual-test)))
#+end_src

Hmmm... ~imp--feature-nomalize-chain~ already unqoutes.

#+begin_src elisp
(imp-parser-normalize-name ''foo)
#+end_src

#+RESULTS:
: quote/foo

#+begin_src elisp
(imp--feature-normalize-chain ''foo)
#+end_src

#+begin_src elisp
(imp--list-flatten ''foo t)
#+end_src



** ├DONE───┤ Deduplicate when joining paths?
CLOSED: [2025-10-21 Tue 16:49]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-21 Tue 16:49]
:END:

This was fixed in [[*imp-parser keyword: ~:root~?][imp-parser keyword: ~:root~?]]

** ├DONE───┤ parser.el -> path.el
CLOSED: [2025-10-23 Thu 16:29]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-23 Thu 16:29]
:END:

;; TODO: MOVE TO path.el
  - [[file:source/core/packages/imp/parser.el::;; TODO: MOVE TO path.el][here]]

** ├DONE───┤ imp-parser keyword path: error when func sexpr
CLOSED: [2025-10-23 Thu 22:58]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-23 Thu 22:58]
- State "├CURRENT┤"  from              [2025-10-23 Thu 16:45]
:END:

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp/init
     :path (imp-path-join user-emacs-directory
                          "path/to/imp")
     :root t)))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-number-of-arguments symbol-name 0)
  (symbol-name)
  (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg))
  (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg))))
  (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path imp-path-join)
  #f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x))(imp-path-join)
  mapcar(#f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x)) (imp-path-join user-emacs-directory "path/to/imp"))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path (imp-path-join user-emacs-directory "path/to/imp"))
  #f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x))((imp-path-join user-emacs-directory "path/to/imp"))
  mapcar(#f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x)) ((imp-path-join user-emacs-directory "path/to/imp")))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (let ((path (imp-parser-normalize-path-arg feature keyword arg))) (cond ((stringp path) (imp-path-canonical path)) ((and (listp path) (listp (cdr path))) (mapcar #'(lambda (x) (imp-parser-normalize-path feature keyword x)) path)) (t (imp--error 'imp-parser-normalize-path "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of path) path))))
  imp-parser-normalize-path(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (let ((funcname 'imp-parser-normalize/:path) (path (imp-parser-normalize-path feature keyword arg)) (feature-path (imp-feature-split feature))) (if (proper-list-p path) (progn (setq path (car path)))) (if (and (not path) (imp-feature-root feature)) (progn (setq path (imp-path-root-get (imp-feature-root feature))) (setq feature-path (imp-feature-unrooted feature)))) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up as absolute: got: '%s' -> '%s'" feature keyword arg path)) (setq path (apply #'imp-path-join path feature-path)) path)
  imp-parser-normalize/:path(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  funcall(imp-parser-normalize/:path imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (and (functionp normalizer) (funcall normalizer name keyword args))
  (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string))))
  (if (null input) plist (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string)))))
  imp-parser-normalize-plist(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t) nil imp-parser-merge-keys)
  (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys))
  (let* ((name-symbol (if (stringp name) (intern name) name)) (name-string (symbol-name name-symbol))) (setq args (delq 'elisp--witness--lisp args)) (setq args (imp-parser-unalias-keywords name-symbol args)) (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys)) (let ((tail imp-parser-defaults)) (while tail (let ((spec (car tail))) (if (let ((func ...)) (if (and func ...) (funcall func name args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args ... ...)))) (setq tail (cdr tail))))) (imp-parser-sort-keywords args))
  imp-parser-normalize-keywords(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)
  apply(#f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* ...) (args* ...) (imp-parser--form ...)) (if (eq imp-parser-verbose ...) (progn ... ... ... ...)) (imp-parser-process-keywords name* args*)))))) (imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  macroexpand-1((imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))
  (progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))))
  eval((progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

That ~symbol-name~ call is [[file:source/core/packages/imp/parser.el::symbol-name arg][here]]

fixed?
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp/init
     :path (imp-path-join user-emacs-directory
                          "path/to/imp")
     :root t)))
#+end_src

nope
#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-normalize/:path: imp:/init: ‘:path’ should end up as absolute: got: ((imp-path-join user-emacs-directory \"path/to/imp\")) -> (\"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join\" \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005\" \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp\")")
  signal(error ("[ERROR--]: imp-parser-normalize/:path: imp:/init: ‘:path’ should end up as absolute: got: ((imp-path-join user-emacs-directory \"path/to/imp\")) -> (\"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join\" \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005\" \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp\")"))
  error("[ERROR--]: imp-parser-normalize/:path: %S: `%S' should end up as absolute: got: %S -> %S" imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")) ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp"))
  apply(error "[ERROR--]: imp-parser-normalize/:path: %S: `%S' should end up as absolute: got: %S -> %S" (imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")) ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp")))
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error imp-parser-normalize/:path "%S: `%S' should end up as absolute: got: %S -> %S" (imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")) ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp")))
  imp--error(imp-parser-normalize/:path "%S: `%S' should end up as absolute: got: %S -> %S" imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")) ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp"))
  (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up as absolute: got: %S -> %S" feature keyword arg path))
  (let ((funcname 'imp-parser-normalize/:path) (path (imp-parser-normalize-path feature keyword arg)) (feature-path (imp-feature-split feature))) (if (proper-list-p path) (progn (setq path (car path)))) (if (and (not path) (imp-feature-root feature)) (progn (setq path (imp-path-root-get (imp-feature-root feature))) (setq feature-path (imp-feature-unrooted feature)))) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up as absolute: got: %S -> %S" feature keyword arg path)) (setq path (apply #'imp-path-join path feature-path)) path)
  imp-parser-normalize/:path(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  funcall(imp-parser-normalize/:path imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (and (functionp normalizer) (funcall normalizer name keyword args))
  (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string))))
  (if (null input) plist (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string)))))
  imp-parser-normalize-plist(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t) nil imp-parser-merge-keys)
  (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys))
  (let* ((name-symbol (if (stringp name) (intern name) name)) (name-string (symbol-name name-symbol))) (setq args (delq 'elisp--witness--lisp args)) (setq args (imp-parser-unalias-keywords name-symbol args)) (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys)) (let ((tail imp-parser-defaults)) (while tail (let ((spec (car tail))) (if (let ((func ...)) (if (and func ...) (funcall func name args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args ... ...)))) (setq tail (cdr tail))))) (imp-parser-sort-keywords args))
  imp-parser-normalize-keywords(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)
  apply(#f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* ...) (args* ...) (imp-parser--form ...)) (if (eq imp-parser-verbose ...) (progn ... ... ... ...)) (imp-parser-process-keywords name* args*)))))) (imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  macroexpand-1((imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))
  (progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))))
  eval((progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

#+begin_quote
[ERROR--]: imp-parser-normalize/:path:
imp:/init:
‘:path’ should end up as absolute:
got:
  ((imp-path-join user-emacs-directory "path/to/imp"))
-> ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/imp-path-join"
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005"
    "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/path/to/imp")
#+end_quote

WTF is this?
error with normalize-value's output?

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp/init
     :path (imp-path-join user-emacs-directory
                          "path/to/imp")
     :root t)))
#+end_src

#+begin_quote
ipnpa: arg: imp-path-join value: (symbol-value 'imp-path-join)
ipnpa: arg: user-emacs-directory value: (symbol-value 'user-emacs-directory)
#+end_quote

#+begin_quote
ipm/:p arg: ((imp-path-join user-emacs-directory "path/to/imp"))
ipnpa: arg: imp-path-join value: (symbol-value 'imp-path-join)
ipnpa: arg: user-emacs-directory value: (symbol-value 'user-emacs-directory)
#+end_quote

╔════════╦════════════╦══════════════════════════════════════════════════════════════════════════════════════════════════════════╗
╠══TODO══╣            ║                                                                                                          ║
╠══TODO══╬══tomorrow══╣                                            ¡¡¡YOU ARE HERE!!!                                            ║
╠══TODO══╣            ║                                                                                                          ║
╚════════╩════════════╩══════════════════════════════════════════════════════════════════════════════════════════════════════════╝
Mmmh... reduce list to first?
It'll still get split, probably.
Special case for functions?
  - [[file:source/core/packages/imp/parser.el::cond ((stringp path][here?]]

I think I need a "normalize input func" like ~imp-parser-normalize-value~

You get a list of whatever in ~imp-parser-normalize/:*~, right?
#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp/init
     :path (imp-path-join user-emacs-directory
                          "path/to/imp")
     :root t)))
#+end_src

#+begin_quote
ipn/:p(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
#+end_quote

why does this not work?
#+begin_src elisp
(imp-parser-normalize-path-one-arg 'user :path 'user-emacs-directory)
#+end_src

it calls ~imp-parser-normalize-eval~, which...
#+begin_src elisp
(imp-parser-normalize-eval 'user-emacs-directory)
#+end_src

#+RESULTS:
: user-emacs-directory

ok, that is how that func works.

So I need one of each:
#+begin_src elisp
(eval arg)
`(symbol-value ',arg)
#+end_src
  - [X] k
  - [X] ditto


** ├DONE───┤ imp-parser: clean up commented out code
CLOSED: [2025-10-23 Thu 23:55]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-23 Thu 23:55]
:END:

Make sure there are no refs to each func/var first.


* ├DONE───┤ gptel: modify org mode layout?
CLOSED: [2025-10-24 Fri 00:08]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-24 Fri 00:08]
:END:

Can I get, like...

#+begin_quote
human> blah blah blah

InternGPT>
lorem ipsum dolor sit amet...
#+end_quote

Look in [[file:~/.config/emacs/elpa/gptel-20250818.648/gptel-org.el::;;; gptel-org.el --- Org functions for gptel -*- lexical-binding: t; -*-][here]] somewhere.

* ├SUCCESS┤ imp-parser MVP
CLOSED: [2025-11-03 Mon 21:46]
:LOGBOOK:
- State "├SUCCESS┤"  from "├DONE───┤"  [2025-11-03 Mon 21:46]
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-03 Mon 21:46]
- State "├CURRENT┤"  from              [2025-10-24 Fri 13:38]
:END:

After restarting emacs & returning to this branch:
#+begin_src elisp
;; reload imp to get new code.
(load (expand-file-name "source/core/packages/imp/init.el" user-emacs-directory))
(imp-path-root-set 'imp "~/.config/emacs/source/core/packages/imp/")
#+end_src


** ├DONE───┤ Check TODOs
CLOSED: [2025-10-24 Fri 13:22]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-24 Fri 13:22]
:END:

Any that will prevent me from starting to use imp-parser?

Don't see any.

** ├DONE───┤ imp-parser: fix param names
CLOSED: [2025-10-24 Fri 14:14]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-24 Fri 14:14]
:END:

eg NAME -> FEATURE
  - ...or should it be FEATURE -> NAME???
  - [X] k

LABEL is... what? KEYWORD?
  - it is ~(symbol-name keyword)~
  - [X] k

F -> FUNC?
  - [X] k

ARG vs ARGS
  - things that only work on lists should not say ARG.
  - [X] k


Either commit to the underscores or delete 'em.
eg:
#+begin_src elisp
(defsubst imp-parser-normalize-symbol-or-string (_label arg)
  ...)

(defun imp-parser-normalize-symlist (_name keyword args)
  ...)

#+end_src
  - [X] k


** ├DONE───┤ provide.el
CLOSED: [2025-10-28 Tue 13:41]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-28 Tue 13:41]
- State "├CURRENT┤"  from "├DONE───┤"  [2025-10-28 Tue 13:28]
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-27 Mon 23:37]
- State "├CURRENT┤"  from              [2025-10-27 Mon 13:35]
:END:

Might need to rework `imp-provide` and `imp-require` for new imp feature names?

Do want them to be macros

Do need to rework all callers.
#+begin_src elisp
(imp-provide :imp 'parser)
#+end_src

should be:
#+begin_src elisp
;; macro so no quotes required
(imp-provide imp parser)
;; But still allowed.
(imp-provide 'imp 'parser)
#+end_src

imp-unprovide [[file:source/core/packages/imp/provide.el::defun imp-unprovide (&rest feature][here]]
  - k

aight. fix all refs.
  - k

** ├DONE───┤ require.el
CLOSED: [2025-10-28 Tue 14:33]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-28 Tue 14:33]
- State "├CURRENT┤"  from              [2025-10-28 Tue 14:11]
:END:

same deal as [[*provide.el][provide.el]]

Might need to rework `imp-provide` and `imp-require` for new imp feature names?

Do want them to be macros

Do need to rework all callers.
#+begin_src elisp
(imp-require :imp 'parser)
#+end_src

should be:
#+begin_src elisp
;; macro so no quotes required
(imp-require imp parser)
;; But still allowed.
(imp-require 'imp 'parser)
#+end_src

Mmmh... Don't wanna recode this and half of load.el now.
Don't really need for MVP?

Error after easy checks.
  - k

comment out and =TODO(require)= the rest.
  - k

rework callers
  - k

** ├DONE───┤ delete imp/flag.el
CLOSED: [2025-10-28 Tue 14:41]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-28 Tue 14:41]
:END:

** ├DONE───┤ replace imp-load with imp-parser in all of .emacs.d
CLOSED: [2025-10-28 Tue 15:30]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-28 Tue 15:30]
- State "├CURRENT┤"  from              [2025-10-28 Tue 15:05]
:END:

Make sure this is a functional, working MVP.
Convert init.el (or something) over to imp-parse and see if it can handle it

old:
#+begin_src elisp
(imp-load :feature  '(:user mode org)
          :path     "mode/org" ;; (imp-path-current-dir-relative :user)
          :filename "init")
#+end_src

new/test:
#+begin_src elisp
(imp-parser '(user mode org))
(imp-parser org :path pwd)
#+end_src


** ├DONE───┤ imp-timing: fix calls
CLOSED: [2025-10-28 Tue 16:07]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-28 Tue 16:07]
:END:

callers now:
#+begin_src elisp
(imp-timing
 '(:user mode org)
 (imp-file-current)
 (imp-path-current-dir)

...
#+end_src

we only have PATH arg now, no filename
fix:
#+begin_src elisp
(imp-timing
 '(user mode org)
 (imp-path-current-file)

...
#+end_src

deadgrep it

** ├DONE───┤ imp-parser: rename?
CLOSED: [2025-10-29 Wed 14:10]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-29 Wed 14:10]
:END:

~parser.el~ is 1500 lines long. Split it up?
Move funcs to where they should be in imp's existing files

move group, version
  - [X] k

Delete/move old imp-load func(s).
  - delete the `imp-load` funcs themselves.
  - [X] delete all code in load.el

Rename ~imp-parser~ to ~imp~ +imp-load? imp-load-parser?+
  - only rename imp-parser and imp-parser-core
  - move those to load.el
  - [X] k

Move keyword funcs to... load.el?
  - How long/unweildy does that make it?
    - ~500 lines
  - [X] k

Move defcustoms to settings.el
  - [X] k

Move keyword processing funcs to load.el
  - [X] k

leave rest of imp-parser for others to use
  - How early in the load can it be?
  - [X] k

delete imp-parser-error, replace with imp--error
  - [X] k

** ├KILLED─┤ reduce imp--error's impact on backtrace
CLOSED: [2025-10-29 Wed 15:10]
:LOGBOOK:
- State "├KILLED─┤"  from "├CURRENT┤"  [2025-10-29 Wed 15:10] \\
  didn't work
- State "├CURRENT┤"  from              [2025-10-29 Wed 14:22]
:END:

Convert the funcs it uses into defsubst?
mmmh... nope.

** ├DONE───┤ rename calls to `imp-parser` to `imp`
CLOSED: [2025-10-29 Wed 16:21]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-29 Wed 16:21]
- State "├CURRENT┤"  from              [2025-10-29 Wed 15:11]
:END:

** ├DONE───┤ './' in feature
CLOSED: [2025-10-29 Wed 16:20]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-10-29 Wed 16:20]
:END:



** ├DONE───┤ small test
CLOSED: [2025-10-30 Thu 13:51]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-30 Thu 13:51]
- State "├CURRENT┤"  from "├WAITING┤"  [2025-10-29 Wed 16:26]
- State "├WAITING┤"  from "├CURRENT┤"  [2025-10-28 Tue 22:26]
- State "├CURRENT┤"  from              [2025-10-28 Tue 16:16]
:END:

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el 'foo))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-path-parent: PATH is not a string! nil")
  signal(error ("[ERROR--]: imp-path-parent: PATH is not a string! nil"))
  error("[ERROR--]: imp-path-parent: PATH is not a string! %S" nil)
  apply(error "[ERROR--]: imp-path-parent: PATH is not a string! %S" nil)
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq lists (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error "imp-path-parent" "PATH is not a string! %S" (nil))
  imp--error("imp-path-parent" "PATH is not a string! %S" nil)
  (cond ((not (stringp path)) (imp--error "imp-path-parent" "PATH is not a string! %S" path)) ((imp--path-dir? path) (directory-file-name (file-name-directory (directory-file-name path)))) (t (directory-file-name (file-name-directory path))))
  imp-path-parent(nil)
  (list 'imp-path-root-set (list 'quote arg) (imp-path-parent (plist-get state :path-load)))
  (list (list 'imp-path-root-set (list 'quote arg) (imp-path-parent (plist-get state :path-load))))
  (imp-parser-concat (list (list 'imp-path-root-set (list 'quote arg) (imp-path-parent (plist-get state :path-load)))) (imp-parser-process-keywords name rest state))
  imp-parser-handler/:root(namespaced :root namespaced (:error t :optional nil) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" :path-load nil))
  funcall(imp-parser-handler/:root namespaced :root namespaced (:error t :optional nil) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" :path-load nil))
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(namespaced (:root namespaced :error t :optional nil) (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" :path-load nil))
  imp-parser-handler/:path(namespaced :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" (:root namespaced :error t :optional nil) nil)
  funcall(imp-parser-handler/:path namespaced :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" (:root namespaced :error t :optional nil) nil)
  (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler)))))
  (if (null plist) (imp-parser-load name state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp-parser-error (format "%s is not a keyword" keyword))) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym name keyword arg rest state) (imp-parser-error (format "Keyword handler not defined: %s" handler))))))
  imp-parser-process-keywords(namespaced (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el/namespaced" :root namespaced :error t :optional nil))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(namespaced :root :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
  macroexpand((imp-parser namespaced :root :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)))
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

Bad error; bad data got too far. Error check path-load before setting.
  - k

run again; better error?

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

oh; path is wrong
...should we check if path by itself is a load path before adding feature to it?
  - sure

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

yay; it got somewhere!
#+begin_quote
loading namespaced...
├─loading elisp/init...
│ ├─loading elisp...
│ │ ├─loading types...
│ │ │ └─00.0036 seconds
│ │ ├─loading functions...
│ │ │ └─00.0934 seconds
│ │ └─00.0974 seconds
│ └─00.1014 seconds
├─loading buffer/init...
#+end_quote

#+begin_src backtrace
Debugger entered--Lisp error: (wrong-number-of-arguments symbol-name 0)
  (symbol-name)
  (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg))
  (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg))))
  (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path imp-path-join)
  #f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x))(imp-path-join)
  mapcar(#f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x)) (imp-path-join user-emacs-directory "path/to/imp"))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path (imp-path-join user-emacs-directory "path/to/imp"))
  #f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x))((imp-path-join user-emacs-directory "path/to/imp"))
  mapcar(#f(lambda (x) [(keyword :path) (feature imp:/init)] (imp-parser-normalize-path-arg feature keyword x)) ((imp-path-join user-emacs-directory "path/to/imp")))
  (cond ((imp-parser-normalize-path-symbol feature keyword arg)) ((imp-parser-normalize-path-string feature keyword arg)) ((and arg (or (imp-parser-non-nil-symbolp arg) (functionp arg))) (let ((value (imp-parser-normalize-value keyword arg))) (condition-case _ (imp-parser-normalize-path-arg feature keyword (eval value)) (error (if (imp-parser-non-nil-symbolp arg) (symbol-name) (imp--error 'imp-parser-normalize-path-arg "`%s' couldn't evaluate %s: '%s'" keyword (type-of arg) arg)))))) ((and (listp arg) (listp (cdr arg))) (mapcar #'(lambda (x) (imp-parser-normalize-path-arg feature keyword x)) arg)) (t (imp--error 'imp-parser-normalize-path-arg "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of arg) arg)))
  imp-parser-normalize-path-arg(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (let ((path (imp-parser-normalize-path-arg feature keyword arg))) (cond ((stringp path) (imp-path-canonical path)) ((and (listp path) (listp (cdr path))) (mapcar #'(lambda (x) (imp-parser-normalize-path feature keyword x)) path)) (t (imp--error 'imp-parser-normalize-path "`%s' wants a path (or list of paths). " "Don't know what to do with %s: '%s'" keyword (type-of path) path))))
  imp-parser-normalize-path(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (let ((funcname 'imp-parser-normalize/:path) (path (imp-parser-normalize-path feature keyword arg)) (feature-path (imp-feature-split feature))) (if (proper-list-p path) (progn (setq path (car path)))) (if (and (not path) (imp-feature-root feature)) (progn (setq path (imp-path-root-get (imp-feature-root feature))) (setq feature-path (imp-feature-unrooted feature)))) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up as absolute: got: '%s' -> '%s'" feature keyword arg path)) (setq path (apply #'imp-path-join path feature-path)) path)
  imp-parser-normalize/:path(imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  funcall(imp-parser-normalize/:path imp:/init :path ((imp-path-join user-emacs-directory "path/to/imp")))
  (and (functionp normalizer) (funcall normalizer name keyword args))
  (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string))))
  (if (null input) plist (let* ((keyword (car input)) (xs (imp-parser-split-list #'keywordp (cdr input))) (args (car xs)) (tail (cdr xs)) (normalizer (intern-soft (concat "imp-parser-normalize/" (symbol-name keyword)))) (arg (and (functionp normalizer) (funcall normalizer name keyword args))) (error-string (format "Unrecognized keyword: %s" keyword))) (if (memq keyword imp-parser-keywords) (progn (setq plist (imp-parser-normalize-plist name tail plist merge-function)) (plist-put plist keyword (if (plist-member plist keyword) (funcall merge-function keyword arg (plist-get plist keyword)) arg))) (if imp-parser-ignore-unknown-keywords (progn (display-warning 'imp-parser error-string) (imp-parser-normalize-plist name tail plist merge-function)) (imp-parser-error error-string)))))
  imp-parser-normalize-plist(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t) nil imp-parser-merge-keys)
  (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys))
  (let* ((name-symbol (if (stringp name) (intern name) name)) (name-string (symbol-name name-symbol))) (setq args (delq 'elisp--witness--lisp args)) (setq args (imp-parser-unalias-keywords name-symbol args)) (setq args (imp-parser-normalize-plist name-symbol args nil #'imp-parser-merge-keys)) (let ((tail imp-parser-defaults)) (while tail (let ((spec (car tail))) (if (let ((func ...)) (if (and func ...) (funcall func name args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args ... ...)))) (setq tail (cdr tail))))) (imp-parser-sort-keywords args))
  imp-parser-normalize-keywords(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))
  (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))
  (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*)))))
  #f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* (imp-parser-normalize-name name)) (args* (imp-parser-normalize-keywords name* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args))) "\n  -->\n\n" (pp-to-string (cons 'imp-parser (cons 'name* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords name* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" name*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords name* args*))))))(imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)
  apply(#f(lambda (name &rest args) [t] "Load NAME.\n\nUsage:\n\n  (imp-parser name\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; NAME is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                 - A list of strings to join into a path.\n                 - A form that should evaluate to one of the above.\n\n:root ROOT     Create an imp path root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t, use first part of NAME.\n               Example:\n                 (imp-parser imp/init\n                             :path (imp-path-join user-emacs-directory\n                                                  \"path/to/imp\")\n                             :root t)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - NAME isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load NAME if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp-parser declaration\n               until after the named libraries have loaded.\n               Before they have been loaded, no other keyword\n               has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((name* ...) (args* ...) (imp-parser--form ...)) (if (eq imp-parser-verbose ...) (progn ... ... ... ...)) (imp-parser-process-keywords name* args*)))))) (imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  macroexpand-1((imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))
  (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))
  (progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t))))
  eval((progn (pp-to-string (macroexpand-1 '(imp-parser imp/init :path (imp-path-join user-emacs-directory "path/to/imp") :root t)))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

why is a "path/to/imp" sample being used?!
#+begin_quote
imp-parser-normalize-keywords(imp:/init (:path (imp-path-join user-emacs-directory "path/to/imp") :root t))
#+end_quote

deadgrep didn't turn up anything useful.
reload all of imp?
  - ~M-X eval-buffer~ [[file:source/core/packages/imp/init.el][here]]
  - [X] k

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

fix this guy's feature arg
(imp-path-root-set 'buffer
                   (imp-path-current-dir)
                   "init.el")

hmm...
Go through [[file:source/core/packages/imp/path.el][path.el]] and clean up.

hm...
Actually let's split up parser.el first

Wait on [[*imp-parser: rename?][imp-parser: rename?]]
  - [X] k
  - [X] also some other stuff

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-normalize/:path: namespaced: ‘:path’ should end up with an absolute path: got: ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) -> (\"~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el\") -> nil")
  signal(error ("[ERROR--]: imp-parser-normalize/:path: namespaced: ‘:path’ should end up with an absolute path: got: ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) -> (\"~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el\") -> nil"))
  error("[ERROR--]: imp-parser-normalize/:path: %S: `%S' should end up with an absolute path: got: %S -> %S -> %S" namespaced :path ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) ("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") nil)
  apply(error "[ERROR--]: imp-parser-normalize/:path: %S: `%S' should end up with an absolute path: got: %S -> %S -> %S" (namespaced :path ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) ("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") nil))
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error imp-parser-normalize/:path "%S: `%S' should end up with an absolute path: got: %S -> %S -> %S" (namespaced :path ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) ("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") nil))
  imp--error(imp-parser-normalize/:path "%S: `%S' should end up with an absolute path: got: %S -> %S -> %S" namespaced :path ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)) ("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") nil)
  (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up with an absolute path: got: %S -> %S -> %S" feature keyword args paths path))
  (let* ((funcname 'imp-parser-normalize/:path) (paths (imp-parser-normalize-paths feature keyword args)) (feature-path (imp-feature-split feature)) (path (car paths))) (setq path (imp-parser-normalize-path-feature feature keyword path)) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up with an absolute path: got: %S -> %S -> %S" feature keyword args paths path)) path)
  imp-parser-normalize/:path(namespaced :path ((imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el)))
...
#+end_src
  - [X] oops. fixed.

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

errored before it could load anything:
#+begin_src backtrace
Debugger entered--Lisp error: (error "Eager macro-expansion failure: (wrong-type-argument stringp nil)")
  signal(error ("Eager macro-expansion failure: (wrong-type-argument stringp nil)"))
  error("Eager macro-expansion failure: %S" (wrong-type-argument stringp nil))
  internal-macroexpand-for-load((let ((imp--macro-feature (imp--feature-normalize-chain :namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path (imp-path-current-file)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (imp "./elisp/init") (imp "./buffer/init") (imp "./unit/init") (imp "./datetime/init") (imp "./str/init") (imp "./theme/init")) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (imp "./elisp/init") (imp "./buffer/init") (imp "./unit/init") (imp "./datetime/init") (imp "./str/init") (imp "./theme/init"))) t)
  eval-buffer(#<buffer  *load*> nil "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil t)  ; Reading at buffer position 2038
  load-with-code-conversion("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil t)
  load("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil nomessage)
  (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))
  (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))
  (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)))
  (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))))
  (progn (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let (...) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" ... ...)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)))))
  eval((progn (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

well this looks fine.
#+begin_quote
load("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil nomessage)
#+end_quote

oh there's something helpful...
#+begin_quote
eval-buffer(#<buffer  *load*> nil "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil t)  ; Reading at buffer position 2038
#+end_quote

#+begin_quote
Reading at buffer position 2038
#+end_quote

That's the end qoute from the ~imp-timing~ macro.

So that ~imp-timing~ macro expanded to:
#+begin_src elisp
(let ((imp--macro-feature (imp--feature-normalize-chain :namespaced)))
  (if (and (imp-timing-enabled?)
           (not (imp--timing-feature-duplicate? imp--macro-feature)))
      (let ((imp--macro-path (imp-path-current-file))
            (imp--macro-time (current-time)))
        (setq imp--timing-feature-current imp--macro-feature)
        (imp--timing-start imp--macro-feature imp--macro-path)
        (prog1
            (let ((imp--timing-indent ...))
              (imp "./elisp/init")
              (imp "./buffer/init")
              (imp "./unit/init")
              (imp "./datetime/init")
              (imp "./str/init")
              (imp "./theme/init"))
          (setq imp--timing-feature-current nil)
          (imp--timing-end imp--macro-time)))
    (imp "./elisp/init")
    (imp "./buffer/init")
    (imp "./unit/init")
    (imp "./datetime/init")
    (imp "./str/init")
    (imp "./theme/init")))
#+end_src

Which got the stringp nil error.
#+begin_quote
error("Eager macro-expansion failure: %S" (wrong-type-argument stringp nil))
#+end_quote

But what goes in the ellipsis?
#+begin_src elisp
(let ((imp--macro-feature (imp--feature-normalize-chain :namespaced)))
  (if (and (imp-timing-enabled?)
           (not (imp--timing-feature-duplicate? imp--macro-feature)))
      (let ((imp--macro-path (imp-path-current-file))
            (imp--macro-time (current-time)))
        (setq imp--timing-feature-current imp--macro-feature)
        (imp--timing-start imp--macro-feature imp--macro-path)
        (prog1
            (let ((imp--timing-indent ...))
              ;; (imp "./elisp/init")
              ;; (imp "./buffer/init")
              ;; (imp "./unit/init")
              ;; (imp "./datetime/init")
              ;; (imp "./str/init")
              ;; (imp "./theme/init")
              "with timing")
          (setq imp--timing-feature-current nil)
          (imp--timing-end imp--macro-time)))
    ;; (imp "./elisp/init")
    ;; (imp "./buffer/init")
    ;; (imp "./unit/init")
    ;; (imp "./datetime/init")
    ;; (imp "./str/init")
    ;; (imp "./theme/init")
    "no timing"))
#+end_src

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-timing
       :namespaced
       (imp-path-current-file)
     "hello there")))
#+end_src

#+RESULTS:
#+begin_example elisp
(let ((imp--macro-feature (imp--feature-normalize-chain :namespaced)))
  (if
      (and (imp-timing-enabled?)
           (not (imp--timing-feature-duplicate? imp--macro-feature)))
      (let
          ((imp--macro-path (imp-path-current-file))
           (imp--macro-time (current-time)))
        (setq imp--timing-feature-current imp--macro-feature)
        (imp--timing-start imp--macro-feature imp--macro-path)
        (prog1
            (let ((imp--timing-indent (1+ imp--timing-indent))) "hello there")
          (setq imp--timing-feature-current nil)
          (imp--timing-end imp--macro-time)))
    "hello there"))
#+end_example

Mmh. So not imp-timing's fault.

Must be this guy:
#+begin_src elisp
(imp "./elisp/init")
#+end_src

How to bubble these errors up better?
With like a stack trace of where the error actually came from?
Cuz it would've been nice to see this instead:
#+begin_src backtrace
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  locate-file-internal(nil ("/") (".so" ".so.gz" ".elc" ".elc.gz" ".el" ".el.gz") nil)
  locate-file(nil ("/") (".so" ".so.gz" ".elc" ".elc.gz" ".el" ".el.gz"))
  imp-path-load-file(nil)
  (if (imp-path-load-file path) path (let* ((funcname 'imp-parser-normalize-path-feature) (append-to-path (imp-feature-split feature))) (if path nil (cond ((imp-feature-root feature) (setq path (imp-path-root-get (imp-feature-root feature))) (setq append-to-path (imp-feature-unrooted feature))) ((string-prefix-p "./" (symbol-name feature)) (setq path (imp-path-current-dir)) (setq append-to-path (cdr append-to-path))) (t nil))) (if (and (stringp path) (file-name-absolute-p path)) (progn (apply #'imp-path-join path append-to-path)))))
  imp-parser-normalize-path-feature(\./elisp/init :path nil)
  (setq path (imp-parser-normalize-path-feature feature keyword path))
  (let* ((funcname 'imp-parser-normalize/:path) (paths (imp-parser-normalize-paths feature keyword args)) (feature-path (imp-feature-split feature)) (path (car paths))) (setq path (imp-parser-normalize-path-feature feature keyword path)) (if (and (stringp path) (file-name-absolute-p path)) nil (imp--error funcname "%S: `%S' should end up with an absolute path: got: %S -> %S -> %S" feature keyword args paths path)) path)
  imp-parser-normalize/:path(\./elisp/init :path nil)
  (lambda (feature args) (imp-parser-normalize/:path feature :path nil))(\./elisp/init nil)
  funcall((lambda (feature args) (imp-parser-normalize/:path feature :path nil)) \./elisp/init nil)
  (if (and func (functionp func)) (funcall func feature args) (eval func))
  (let ((func (nth 1 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func)))
  (imp-parser-plist-maybe-put args (nth 0 spec) (let ((func (nth 1 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))))
  (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let ((func (nth 1 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func)))))
  (progn (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let ((func (nth 1 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))))))
  (if (let ((func (nth 2 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let ((func (nth 1 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func)))))))
  (let ((spec (car tail))) (if (let ((func (nth 2 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let ((func ...)) (if (and func ...) (funcall func feature args) (eval func))))))) (setq tail (cdr tail)))
  (while tail (let ((spec (car tail))) (if (let ((func (nth 2 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let (...) (if ... ... ...)))))) (setq tail (cdr tail))))
  (let ((tail imp-parser-defaults)) (while tail (let ((spec (car tail))) (if (let ((func (nth 2 spec))) (if (and func (functionp func)) (funcall func feature args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args (nth 0 spec) (let ... ...))))) (setq tail (cdr tail)))))
  (let* ((feature-symbol (if (stringp feature) (intern feature) feature)) (feature-string (symbol-name feature-symbol))) (setq args (delq 'elisp--witness--lisp args)) (setq args (imp-parser-unalias-keywords feature-symbol args)) (setq args (imp-parser-normalize-plist feature-symbol args nil #'imp-parser-merge-keys)) (let ((tail imp-parser-defaults)) (while tail (let ((spec (car tail))) (if (let ((func ...)) (if (and func ...) (funcall func feature args) (eval func))) (progn (setq args (imp-parser-plist-maybe-put args ... ...)))) (setq tail (cdr tail))))) (imp-parser-sort-keywords args))
  imp-parser-normalize-keywords(\./elisp/init nil)
  (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))
  (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))
  (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))))
  #f(lambda (feature &rest args) [t] "Load FEATURE.\n\nUsage:\n\n  (imp feature\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; FEATURE is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                   - absolute or relative\n                   - prefixes:\n                     - \"./\" - relative to `imp-path-current-dir'\n                     - \":/\" - relative to FEATURE's root\n                 - A symbol whose value is a path string.\n                   - example: `user-emacs-directory'\n                 - A symbol whose name is known.\n                   - examples:\n                     - `pwd' - `imp-path-current-dir'\n                     - `.emacs' - `user-emacs-directory'\n                     - `root' - `imp-feature-root'\n                   - See func `imp-parser-normalize-path-symbol'\n                 - A form/function that evaluates to a path string.\n                   - (imp-path-join user-emacs-directory \"path/to/imp\")\nTODO(path): Do we want this to be the solution for lists?\n                 - A list of the above to join into a path.\nTODO(path): Alternative is a list of paths to try for locating the file.\n\n:root ROOT     Create an imp feature root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t or a flag (arg-less), use first part of FEATURE.\n               Example:\n                 (imp imp/init\n                   :path (imp-path-join user-emacs-directory\n                                        \"path/to/imp\")\n                   :root)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - FEATURE isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load FEATURE if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp declaration until after the\n               named features have loaded. Before they have been loaded, no\n               other keyword has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons 'feature* args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons 'feature* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords feature* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))))("./elisp/init")
  macroexpand((imp "./elisp/init"))
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

Fix ~imp-path-load-file~
#+begin_src elisp
(imp-path-load-file nil)
#+end_src
  - [X] k

#+begin_src elisp
(imp "./elisp/init")
#+end_src

better
#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init\"")
  signal(error ("[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init\""))
  error("[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: %S" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init")
  apply(error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: %S" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init")
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error imp-parser-handler/:path ("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") ("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init"))
  imp--error(imp-parser-handler/:path ("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init")
  (if path-load (setq state (imp-parser-plist-maybe-put state :path-load path-load)) (imp--error 'imp-parser-handler/:path '("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") arg))
  (let* ((path-load (and t (imp-path-load-file arg)))) (if path-load (setq state (imp-parser-plist-maybe-put state :path-load path-load)) (imp--error 'imp-parser-handler/:path '("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") arg)))
  imp-parser-handler/:path(\./elisp/init :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init" (:error t :optional nil) nil)
  funcall(imp-parser-handler/:path \./elisp/init :path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init" (:error t :optional nil) nil)
  (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler)))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp--error 'imp-parser-process-keywords "%s is not a keyword" keyword)) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler))))
  (if (null plist) (imp-parser-load feature state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp--error 'imp-parser-process-keywords "%s is not a keyword" keyword)) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler)))))
  imp-parser-process-keywords(\./elisp/init (:path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/elisp/init" :error t :optional nil))
  (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))
  (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))
  (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))))
  #f(lambda (feature &rest args) [t] "Load FEATURE.\n\nUsage:\n\n  (imp feature\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; FEATURE is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                   - absolute or relative\n                   - prefixes:\n                     - \"./\" - relative to `imp-path-current-dir'\n                     - \":/\" - relative to FEATURE's root\n                 - A symbol whose value is a path string.\n                   - example: `user-emacs-directory'\n                 - A symbol whose name is known.\n                   - examples:\n                     - `pwd' - `imp-path-current-dir'\n                     - `.emacs' - `user-emacs-directory'\n                     - `root' - `imp-feature-root'\n                   - See func `imp-parser-normalize-path-symbol'\n                 - A form/function that evaluates to a path string.\n                   - (imp-path-join user-emacs-directory \"path/to/imp\")\nTODO(path): Do we want this to be the solution for lists?\n                 - A list of the above to join into a path.\nTODO(path): Alternative is a list of paths to try for locating the file.\n\n:root ROOT     Create an imp feature root for ROOT at PATH given in `:path'.\n               See var `imp-path-roots' and func `imp-path-root-set'.\n               If ROOT is t or a flag (arg-less), use first part of FEATURE.\n               Example:\n                 (imp imp/init\n                   :path (imp-path-join user-emacs-directory\n                                        \"path/to/imp\")\n                   :root)\n                 => imp-path-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - FEATURE isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load FEATURE if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp declaration until after the\n               named features have loaded. Before they have been loaded, no\n               other keyword has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons 'feature* args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons 'feature* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords feature* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))))("./elisp/init")
  macroexpand((imp "./elisp/init"))
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

hmm....
Oh. I can't eval that here; needs to be in namespaced dir.

eval this there:
#+begin_src elisp
(imp-parser-normalize-path-feature
 (imp-feature-normalize "./elisp/init")
 :path
 nil)
#+end_src

got:
"/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init"
file:/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init.el
good.

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp "./elisp/init")))
#+end_src

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

yay. got up to ~units~ this time:
#+begin_quote
loading \./elisp/init...
├─loading elisp...
│ ├─loading \./types...
│ │ └─00.0054 seconds
│ ├─loading \./functions...
│ │ └─00.0035 seconds
│ └─00.0092 seconds
└─00.0133 seconds
loading \./buffer/init...
├─loading buffer...
│ ├─loading buffer:/delete...
│ │ └─00.0046 seconds
│ ├─loading buffer:/region...
│ │ └─00.0037 seconds
│ └─00.0088 seconds
└─00.0171 seconds
loading \./unit/init...
#+end_quote

#+begin_src backtrace
Debugger entered--Lisp error: (error "Eager macro-expansion failure: (error \"[ERROR--]: imp-parser-normalize/:path: unit/units: ‘:path’ should end up with an absolute path: got: nil -> nil -> nil\")")
  signal(error ("Eager macro-expansion failure: (error \"[ERROR--]: imp-parser-normalize/:path: unit/units: ‘:path’ should end up with an absolute path: got: nil -> nil -> nil\")"))
  error("Eager macro-expansion failure: %S" (error "[ERROR--]: imp-parser-normalize/:path: unit/units: ‘:path’ should end up with an absolute path: got: nil -> nil -> nil"))
  internal-macroexpand-for-load((let ((imp--macro-feature (imp--feature-normalize-chain :unit))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path (imp-path-current-file)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (imp unit:/units)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (imp unit:/units))) t)
  eval-buffer(#<buffer  *load*-876134> nil "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el" nil t)  ; Reading at buffer position 1017
  load-with-code-conversion("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el" nil t)
  load("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" nil nomessage)
  (let ((imp--timing-indent (1+ imp--timing-indent))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage))
  (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))
  (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-chain '\./unit/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage)))
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path (imp-path-current-file)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...))) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./elisp/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./buffer/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./unit/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./datetime/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./str/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./theme/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme/init" 'nil 'nomessage))))
  (let ((imp--macro-feature (imp--feature-normalize-chain :namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path (imp-path-current-file)) (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...)) (let (...) (if ... ... ...))) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./elisp/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./buffer/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./unit/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./datetime/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./str/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str/init" 'nil 'nomessage))) (let ((imp--macro-feature (imp--feature-normalize-chain '\./theme/init))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme/init" 'nil 'nomessage)))))
  eval-buffer(#<buffer  *load*> nil "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil t)  ; Reading at buffer position 2038
  load-with-code-conversion("/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil t)
  load("~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" nil nomessage)
  (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))
  (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent (1+ imp--timing-indent))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)))
  (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ((imp--timing-indent ...)) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))))
  (progn (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time (current-time))) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let (...) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" ... ...)) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage)))))
  eval((progn (progn (imp-path-root-set 'namespaced "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced") (let ((imp--macro-feature (imp--feature-normalize-chain 'namespaced))) (if (and (imp-timing-enabled?) (not (imp--timing-feature-duplicate? imp--macro-feature))) (let ((imp--macro-path "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el") (imp--macro-time ...)) (setq imp--timing-feature-current imp--macro-feature) (imp--timing-start imp--macro-feature imp--macro-path) (prog1 (let ... ...) (setq imp--timing-feature-current nil) (imp--timing-end imp--macro-time))) (load "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/init.el" 'nil 'nomessage))))) t)
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

#+begin_quote
eval-buffer(#<buffer  *load*-876134> nil
 "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit/init.el" nil t)
Reading at buffer position 1017
#+end_quote

end of an ~imp-timing~ macro again.

Oh right. Need to fix path.el wrt feature.
#+begin_src
(imp-path-root-set :unit
                   (imp-path-current-dir))
imp-path-roots
#+end_src
  - there's a ~:unit~ in there but it's looking for ~unit~ sans colon.

oops. Where's the infinite loop?
#+begin_src elisp
(imp--path-root-dir :imp)
#+end_src

#+begin_quote
cl-prin1: (excessive-lisp-nesting 1622)
cl-prin1: (error "Lisp nesting exceeds ‘max-lisp-eval-depth’") [23 times]
#+end_quote

imp-feature-normalize
  - imp-feature-join
    - imp-feature-root
      - imp--feature-root
        - imp--path-root-dir
          - imp-feature-normalize
            - infinite oops

Remove refs to path.el funcs from feature.el.
Here:
  - imp--feature-root
    - imp--path-root-dir

:thinking:
Rename ~imp-path-roots~ to ~imp-roots~ and put it in an earlier file?
Put it and ~imp-features~ in ~init.el~?
  - [X] k
get rid of path func calls in ~feature.el~
  - [X] k

Go through [[file:source/core/packages/imp/path.el][path.el]] and check for feature-related args.
Fix them to be as lenient as possible, and to use eg imp-feature-normalize.
  - [X] k?
  - [X] commit

Normalize paths before putting into ~imp-roots~.

eval-buffer imp/init.el
#+begin_quote
apply: [ERROR--]: imp--path-root-dir: FEATURE is unknown: imp -> imp
#+end_quote
  - add a `:no-error` to `imp-path-root-set` calls to `imp-path-root-get`.

#+begin_src elisp
(imp-parser namespaced
  :root
  :path (imp-path-join user-emacs-directory 'source 'core 'packages 'namespaced 'init.el))
#+end_src

yay
#+begin_quote
loading namespaced...
├─loading \./elisp/init...
│ ├─loading elisp...
│ │ ├─loading \./types...
│ │ │ └─00.0062 seconds
│ │ ├─loading \./functions...
│ │ │ └─00.0046 seconds
│ │ └─00.0112 seconds
│ └─00.0165 seconds
├─loading \./buffer/init...
│ ├─loading buffer...
│ │ ├─loading buffer:/delete...
│ │ │ └─00.0035 seconds
│ │ ├─loading buffer:/region...
│ │ │ └─00.0033 seconds
│ │ └─00.0071 seconds
│ └─00.0129 seconds
├─loading \./unit/init...
│ ├─loading unit...
│ │ ├─loading unit:/units...
│ │ │ └─00.0051 seconds
│ │ └─00.0054 seconds
│ └─00.0116 seconds
├─loading \./datetime/init...
│ ├─loading datetime...
│ │ ├─loading \./datetime...
│ │ │ └─00.0039 seconds
│ │ ├─loading \./format...
│ │ │ └─00.0036 seconds
│ │ ├─loading \./timestamp...
│ │ │ └─00.0048 seconds
│ │ └─00.0127 seconds
│ └─00.0201 seconds
├─loading \./str/init...
│ ├─loading str...
│ │ ├─loading str:/normalize...
│ │ │ └─00.0050 seconds
│ │ └─00.0053 seconds
│ └─00.0110 seconds
├─loading \./theme/init...
│ ├─loading theme...
│ │ ├─loading theme:/face...
│ │ │ └─00.0040 seconds
│ │ └─00.0042 seconds
│ └─00.0091 seconds
└─00.0904 seconds
#+end_quote


** ├SUCCESS┤ full test
CLOSED: [2025-10-30 Thu 17:10]
:LOGBOOK:
- State "├SUCCESS┤"  from "├DONE───┤"  [2025-10-30 Thu 17:10]
- State "├DONE───┤"  from "├CURRENT┤"  [2025-10-30 Thu 17:10]
- State "├CURRENT┤"  from "├TODO───┤"  [2025-10-30 Thu 16:41]
:END:

...goto ~.emacs.d/init.el~ and ~M-X eval-buffer~?
#+begin_src messages
internal-macroexpand-for-load: Eager macro-expansion failure: (error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/theme/zenburn\"")
#+end_src

#+begin_quote
Cannot find a load path from path.
Is path pointing to a file (with or without ext)?
path: "~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/theme/zenburn"
#+end_quote

oh. Missing "init.el" part of the path.
Should we check for init.el?
  - taht's a question for after MVP

#+begin_src messages
apply: [ERROR--]: imp-path-root-set:
Feature is already an imp root.
FEATURE: :user
feature base: user
path: ~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user
#+end_src

hm. Disable imp timing so I can see the backtraces?
#+begin_src elisp
(setq imp-timing-enabled? nil)
#+end_src

still didn't get a backtrace. :(
#+begin_src messages
internal-macroexpand-for-load: Eager macro-expansion failure: (error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d\""
)
#+end_src

#+begin_quote
Cannot find a load path from path.
Is path pointing to a file (with or without ext)?
path: "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d"
#+end_quote
...

it should not be executing that?!
#+begin_src elisp
  ;; TODO: for now, this way.
  (pcase system-type
    ('gnu/linux
     ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; to figure out path from system-name/host.
     (imp secret.d
       :root
       :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))
    ('windows-nt
     ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; to figure out path from system-name/host.
     (imp secret.d
       :root
       :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))
#+end_src
  - [[file:init.el::(pcase system-type][init.el]]

also.... my "just use path if path is load path" code broke again.
probably in new func ~imp-parser-normalize-path-feature~?
  - [[file:source/core/packages/imp/load.el::defun imp-parser-normalize-path-feature (feature keyword path][here]]

or not.
#+begin_src elisp
  ;; We're done if path itself is a full, loadable path.
  (if (imp-path-load-file path)
      path
#+end_src

#+begin_src elisp
(pp-to-string imp-roots)
#+end_src

#+RESULTS:
#+begin_example
((user "~/.config/emacs/source/user")
 (theme
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/theme")
 (str
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/str")
 (datetime
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/datetime")
 (unit
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/unit")
 (buffer
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/buffer")
 (elisp
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced/elisp")
 (namespaced
  "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/namespaced")
 (imp
   "/home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/core/packages/imp"))
#+end_example

#+begin_src elisp
(pp-to-string imp-features)
#+end_src

#+RESULTS:
: ((namespaced) (theme nil (face)) (str nil (normalize))
:  (datetime nil (timestamp) (format) (datetime)) (unit nil (units))
:  (buffer nil (region) (delete)) (elisp nil (functions) (types))
:  (imp nil nil nil nil nil (package) (require) (load) (provide) (parser)))

#+begin_src elisp
  (pcase system-type
    ('gnu/linux
     ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; to figure out path from system-name/host.
     (imp secret.d
       :root
       :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))
    ('windows-nt
     ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; to figure out path from system-name/host.
     (imp secret.d
       :root
       :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))
#+end_src

#+begin_src backtrace
Debugger entered--Lisp error: (error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d\"")
  signal(error ("[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: \"~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d\""))
  error("[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: %S" "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d")
  apply(error "[ERROR--]: imp-parser-handler/:path: Cannot find a load path from path. Is path pointing to a file (with or without ext)? path: %S" "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d")
  (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail)))
  (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply #'concat string)))) args) (setq tail (cdr tail))))
  (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ((stringp string) string) ((null string) nil) ((listp string) (apply ... string)))) args) (setq tail (cdr tail)))))
  (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond (... string) (... nil) (... ...))) args) (setq tail (cdr tail))))))
  (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink (car tail))) (apply sink (concat prefix caller (if caller ": " "") (cond ... ... ...)) args) (setq tail (cdr tail)))))))
  (if (imp--output-level-get level :sink) (progn (let ((sinks (imp--output-level-get level :sink)) (prefix (imp--output-prefix level)) (caller (imp--output-callers caller))) (if (listp sinks) nil (setq sinks (list sinks))) (let ((tail sinks)) (while tail (let ((sink ...)) (apply sink (concat prefix caller ... ...) args) (setq tail (cdr tail))))))))
  imp--output(:error imp-parser-handler/:path ("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") ("~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d"))
  imp--error(imp-parser-handler/:path ("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d")
  (if path-load (setq state (imp-parser-plist-maybe-put state :path-load path-load)) (imp--error 'imp-parser-handler/:path '("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") arg))
  (let* ((path-load (and t (imp-path-load-file arg)))) (if path-load (setq state (imp-parser-plist-maybe-put state :path-load path-load)) (imp--error 'imp-parser-handler/:path '("Cannot find a load path from path. " "Is path pointing to a file (with or without ext)? " "path: %S") arg)))
  imp-parser-handler/:path(secret.d :path "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d" (:root secret.d :error t :optional nil) nil)
  funcall(imp-parser-handler/:path secret.d :path "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d" (:root secret.d :error t :optional nil) nil)
  (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler))
  (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler)))
  (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp--error 'imp-parser-process-keywords "%s is not a keyword" keyword)) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler))))
  (if (null plist) (imp-parser-load feature state) (let* ((keyword (car plist)) (arg (car (cdr plist))) (rest (cdr (cdr plist)))) (if (keywordp keyword) nil (imp--error 'imp-parser-process-keywords "%s is not a keyword" keyword)) (let* ((handler (concat "imp-parser-handler/" (symbol-name keyword))) (handler-sym (intern handler))) (if (functionp handler-sym) (funcall handler-sym feature keyword arg rest state) (imp--error 'imp-parser-process-keywords "Keyword handler not defined: %s" handler)))))
  imp-parser-process-keywords(secret.d (:path "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d" :root secret.d :error t :optional nil))
  (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons ... args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons ... args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ... ...)))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))
  (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons ... ...)) "\n  -->\n\n" (pp-to-string (cons ... ...)) "\n  ==>\n\n" (pp-to-string (macroexp-progn ...))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))
  (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string ...) "\n  -->\n\n" (pp-to-string ...) "\n  ==>\n\n" (pp-to-string ...)) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))
  (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose ...) (concat "\n\n" ... "\n  -->\n\n" ... "\n  ==>\n\n" ...) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*)))))
  #f(lambda (feature &rest args) [t] "Load FEATURE.\n\nUsage:\n\n  (imp feature\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; FEATURE is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                   - absolute or relative\n                   - prefixes:\n                     - \"./\" - relative to `imp-path-current-dir'\n                     - \":/\" - relative to FEATURE's root\n                 - A symbol whose value is a path string.\n                   - example: `user-emacs-directory'\n                 - A symbol whose name is known.\n                   - examples:\n                     - `pwd' - `imp-path-current-dir'\n                     - `.emacs' - `user-emacs-directory'\n                     - `root' - `imp-feature-root'\n                   - See func `imp-parser-normalize-path-symbol'\n                 - A form/function that evaluates to a path string.\n                   - (imp-path-join user-emacs-directory \"path/to/imp\")\nTODO(path): Do we want this to be the solution for lists?\n                 - A list of the above to join into a path.\nTODO(path): Alternative is a list of paths to try for locating the file.\n\n:root ROOT     Create an imp feature root for ROOT at PATH given in `:path'.\n               See var `imp-roots' and func `imp-path-root-set'.\n               If ROOT is t or a flag (arg-less), use first part of FEATURE.\n               Example:\n                 (imp imp/init\n                   :path (imp-path-join user-emacs-directory\n                                        \"path/to/imp\")\n                   :root)\n                 => imp-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - FEATURE isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load FEATURE if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp declaration until after the\n               named features have loaded. Before they have been loaded, no\n               other keyword has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* (imp-parser-normalize-feature feature)) (args* (imp-parser-normalize-keywords feature* args)) (imp-parser--form (if (eq imp-parser-verbose 'debug) (concat "\n\n" (pp-to-string (cons 'imp (cons 'feature* args))) "\n  -->\n\n" (pp-to-string (cons 'imp (cons 'feature* args*))) "\n  ==>\n\n" (pp-to-string (macroexp-progn (let ((imp-parser-verbose 'errors) (imp-parser-expand-minimally t)) (imp-parser-process-keywords feature* args*))))) ""))) (if (eq imp-parser-verbose 'debug) (progn (message (make-string 40 9473)) (message "%s" feature*) (message (make-string 40 9473)) (message "%s" imp-parser--form))) (imp-parser-process-keywords feature* args*))))))(secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")
  apply(#f(lambda (feature &rest args) [t] "Load FEATURE.\n\nUsage:\n\n  (imp feature\n     [:keyword [option]]...)\n\n:disabled      Flag. Nothing happens; FEATURE is ignored completely if this keyword\n               is present.\n\n:path PATH     Absolute, relative, or rooted path to file.\n               PATH can be:\n                 - A path string.\n                   - absolute or relative\n                   - prefixes:\n                     - \"./\" - relative to `imp-path-current-dir'\n                     - \":/\" - relative to FEATURE's root\n                 - A symbol whose value is a path string.\n                   - example: `user-emacs-directory'\n                 - A symbol whose name is known.\n                   - examples:\n                     - `pwd' - `imp-path-current-dir'\n                     - `.emacs' - `user-emacs-directory'\n                     - `root' - `imp-feature-root'\n                   - See func `imp-parser-normalize-path-symbol'\n                 - A form/function that evaluates to a path string.\n                   - (imp-path-join user-emacs-directory \"path/to/imp\")\nTODO(path): Do we want this to be the solution for lists?\n                 - A list of the above to join into a path.\nTODO(path): Alternative is a list of paths to try for locating the file.\n\n:root ROOT     Create an imp feature root for ROOT at PATH given in `:path'.\n               See var `imp-roots' and func `imp-path-root-set'.\n               If ROOT is t or a flag (arg-less), use first part of FEATURE.\n               Example:\n                 (imp imp/init\n                   :path (imp-path-join user-emacs-directory\n                                        \"path/to/imp\")\n                   :root)\n                 => imp-roots: '((imp \"~/.config/emacs/path/to/imp\") ...)\n\n:error ERR     Value (aka ERROR) can be:\n                 - nil\n                 - non-nil (default)\n                 - A form that should evaluate to one of the above.\n               If ERROR is nil, the function will not raise an error if:\n                 - The file doesn't exist.\n                 - FEATURE isn't provided after loading the file.\n               It will still raise an error if:\n                 - It cannot parse the inputs.\n                 - It cannot determine where to /look/ for the file.\n\n:optional OPT  Load FEATURE if it exists; do nothing if it does not.\n               OPT can be:\n                 - nil (default)\n                 - non-nil\n                 - A form that should evaluate to one of the above.\n\n:requires REQ  Assert that a feature already exists in `features'.\n               If assert fails, handle according to ERROR/OPTIONAL.\n               REQ can be:\n                 - nil\n                 - symbol\n                 - A form that should evaluate to one of the above.\n\n:if EXPR       Initialize and load only if EXPR evaluates to a non-nil value.\n:when EXPR     See `:if'.\n:unless EXPR   Opposite of `:if'.\n               Initialize and load only if EXPR evaluates to a nil value.\n\n:after AFTER   Delay the effect of the imp declaration until after the\n               named features have loaded. Before they have been loaded, no\n               other keyword has any effect at all, and once they have been\n               loaded it is as if `:after' was not specified." (if (memq :disabled args) nil (macroexp-progn (imp-parser-concat (let* ((feature* ...) (args* ...) (imp-parser--form ...)) (if (eq imp-parser-verbose ...) (progn ... ... ... ...)) (imp-parser-process-keywords feature* args*)))))) (secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))
  macroexpand-1((imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el") nil)
  macroexp-macroexpand((imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el") nil)
  macroexp--expand-all((imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))
  macroexp--all-forms(((imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))
  macroexp--expand-all((let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))
  macroexp--all-forms(((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))) nil)
  macroexp--all-clauses((((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))))
  macroexp--expand-all((cond ((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))))
  macroexp--all-forms((progn (cond ((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))))) 1)
  #f(compiled-function (form func) #<bytecode 0x4a4133a35169d59>)(((progn (cond ((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")))))) progn)
  macroexp--expand-all((progn (cond ((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))))))
  macroexpand-all((progn (cond ((eq system-type 'gnu/linux) (let nil (imp secret.d :root :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el"))) ((eq system-type 'windows-nt) (let nil (imp secret.d :root :path "~/.secret.d/emacs/2025-03-13_sn005/init.el"))))))
  elisp--eval-last-sexp(nil)
  #f(compiled-function () #<bytecode 0xa2a0a50c829a>)()
  handler-bind-1(#f(compiled-function () #<bytecode 0xa2a0a50c829a>) (error) eval-expression--debug)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
#+end_src

#+begin_quote
imp-parser-handler/:path:
Cannot find a load path from path.
Is path pointing to a file (with or without ext)?
path: "~/.secret.d/emacs/2025-03-13_sn005/init.el/secret.d"
#+end_quote

wtf mate
that's a valid error
But I'm not on WINDOWS!!!!!!!!!!!
>:(
Why you run the windows case in pcase?

#+begin_src elisp
  (pcase system-type
    ('gnu/linux
     ;; ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; ;; to figure out path from system-name/host.
     ;; (imp secret.d
     ;;   :root
     ;;   :path "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el")
     (message "sane & normal"))
    ('windows-nt
     ;; TODO: macro should allow funcs & symbols for values in plist. e.g. call
     ;; to figure out path from system-name/host.
     ;; (imp secret.d
     ;;   :root
     ;;   :path "~/.secret.d/emacs/2025-03-13_sn005/init.el")
     (message "hello there")))
#+end_src

#+RESULTS:
: sane & normal

Maybe that's just how macros work.
In which case, meh.
Fixing that is not for MVP, probably.

try this:
#+begin_src elisp
  (imp secret.d
    :root
    :path (pcase system-type
            ('gnu/linux
             "~/ocean/vault/.config/secret/emacs/2025-03-13_sn005/init.el")
            ('windows-nt
             "~/.secret.d/emacs/2025-03-13_sn005/init.el")))
#+end_src

#+RESULTS:
: t
Successful load.

oh, yay.
~M-X eval-buffer~ in [[file:init.el][init.el]] was successful!

My whitespace tweaks got erased.
  - but that's a different thing.


** ├DONE───┤ fullest test
CLOSED: [2025-11-03 Mon 13:44]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-03 Mon 13:44]
- State "├CURRENT┤"  from "├TODO───┤"  [2025-11-03 Mon 13:20]
:END:

Now do the whole shebang:
  1. restart emacs
     - debug-on-init?
  2. fix errors
  3. goto 1

Can I just run one from command line while I keep this one for notes & coding?
yeah
~emacs --debug-init~

...fix some imp bugs...

yay; it got past init!

*Warnings* buffer:
#+begin_quote
⛔ Warning (native-compiler): provide.el: Warning: the function ‘imp--feature-add’ is not known to be defined.
⛔ Warning (native-compiler): provide.el: Warning: the function ‘imp--error’ is not known to be defined.
⛔ Warning (native-compiler): provide.el: Warning: the function ‘imp-feature-normalize’ is not known to be defined.
#+end_quote
Hm... But they are known to be defined?
It's from an earlier file.

*Async-native-compile-log* buffer:
#+begin_quote
Compiling /home/main/.config/emacs/source/core/packages/imp/provide.el...

In imp--provide-parse:
provide.el:40:43: Warning: global/dynamic var ‘arg’ lacks a prefix
provide.el:40:43: Warning: global/dynamic var ‘arg’ lacks a prefix

In imp-unprovide:
provide.el:77:2: Warning: docstring has wrong usage of unescaped single quotes (use \=' or different quoting such as `...')
provide.el:135:2: Warning: Unused lexical variable ‘funcname’
provide.el:135:2: Warning: reference to free variable ‘feature’

In end of data:
provide.el: Warning: the function ‘imp--feature-add’ is not known to be defined.
provide.el: Warning: the function ‘imp--error’ is not known to be defined.
provide.el: Warning: the function ‘imp-feature-normalize’ is not known to be defined.
Compilation finished.
#+end_quote

Fixed some....
Fixed more.

Just this remaining in *Async-native-compile-log* buffer:
#+begin_quote
Compiling /home/main/.config/emacs/source/core/packages/imp/provide.el...

In end of data:
provide.el: Warning: the function ‘imp--feature-add’ is not known to be defined.
provide.el: Warning: the function ‘imp--error’ is not known to be defined.
provide.el: Warning: the function ‘imp-feature-normalize’ is not known to be defined.
Compilation finished.
#+end_quote

Let's say good enough for now?

** ├DONE───┤ Rename imp-output buffer with asterisks
CLOSED: [2025-11-03 Mon 13:50]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-11-03 Mon 13:50]
:END:


* ├DONE───┤ namespace
CLOSED: [2025-11-17 Mon 15:42]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-17 Mon 15:42]
- State "├CURRENT┤"  from              [2025-11-03 Mon 22:13]
:END:

BE ON ~feature/namespaced~ GIT BRANCH!!!!

** ├DONE───┤ make most of namespaced stuff loadable
CLOSED: [2025-11-10 Mon 22:35]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-11-10 Mon 22:35]
:END:
done:
  - [X] elisp (done-ish)
  - [X] datetime
  - [X] unit
  - [X] buffer (done-ish)
  - [X] window/init
  - [X] color/init
  - [X] list/init
  - [X] path/init
  - [X] str (finish)
  - [X] theme (finish)
  - [X] buffer/+...

BE ON ~feature/namespaced~ GIT BRANCH!!!!

query regex replace =M-S-C-%=:
  from: int<\([a-z]+\)>
  to:   _:\1

And then?
  - [X] input/init
    - this is my box drawing hydra
    - Not namespaced.
    - [X] move to user/art?
    - [X] add hydra package to init
      - moved to [[*pkg: hydra][pkg: hydra]]
  - [X] output/init
    - this is ~nub~
    - Not namespaced.
    - [X] Put in source/core/packages/_delete-maybe/nub

** ├DONE───┤ ns/emacs sort, refactor, etc
CLOSED: [2025-11-12 Wed 21:32]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-12 Wed 21:32]
- State "├CURRENT┤"  from              [2025-11-10 Mon 22:34]
:END:

1. I don't think I should name this one "emacs".
2. Its actually ~innit~ and ~system~.
3. ~emacs/init.el~ does not load anything.
4. do they really belong in "namespaced"?
   - They belong in source/user/???/...
   - or core/packages/???

well, look at all the files and figure out what to do.


delete files:
  - [X] nine of 'em

move:
  - [X] ns/emacs/os.el -> ns/system/os.el
    - [[file:source/core/packages/namespaced/emacs/init/os.el::;; TODO(namespaced): move to ns/os/init.el][here]]
    - and add to ns/init.el
  - [X] ns/emacs/package-upgrade-* -> ns/package/
    - 2 files
    - and add to ns/init.el
  - [X] ns/emacs/init/* -> ns/emacs/*
    - [X] ns/emacs/server.el -> ???
      - ...this one might actually belong in ~emacs~
      - [[file:source/core/packages/namespaced/emacs/init/server.el][here]]
    - [X] ns/emacs/squelch.el
      - this might actually belong here too

pblblblblfffft
Still can't call it ~emacs~; that already has a feature:
#+begin_src elisp
(featurep 'emacs)
#+end_src

#+RESULTS:
: t

╔════════╦════════════╦══════════════════════════════════════════════════════════════════════════════════════════════════════════╗
╠══TODO══╣            ║                                                                                                          ║
╠══TODO══╬══tomorrow══╣                                            ¡¡¡YOU ARE HERE!!!                                            ║
╠══TODO══╣            ║                                                                                                          ║
╚════════╩════════════╩══════════════════════════════════════════════════════════════════════════════════════════════════════════╝
rename ns/emacs
  - [ ] to?!?
    - [ ] emacsns or emacs-ns or nsemacs or ns-emacs or ns/emacs or ...
    - [ ] emacs-actual

or... move server and squelch elsewhere?
  - [ ] squelch:
    - [ ] ns/squelch.el?
    - [ ] ns/squelch/init.el?
    - [ ] ns/output/squelch.el?
    - [ ] ns/message/squelch.el?
    - Essentially, squelch is a specialized type of noise gate designed to suppress weak signals.
      - https://en.wikipedia.org/wiki/Squelch
  - [ ] server:
    - Emacs's shit is in ~(featurep 'server)~
    - [ ] ns/daemon/init.el
    - [ ] ns/server/init.el
    - [ ] ns/emacs-server/init.el

Hm......
  - dir:     ~emacs~
  - feature: ~ns/emacs~
  - funcs:
    - ~squelch:...~
    - ~emacs:server:...~ or ~server:...~?
yes/no?

Mmmh.....
    - [ ] ns/output/squelch.el
    - [X] ns/emacs-server.el
      - beh. wanna emacs/server.el :(
      - ok use this I guess

refactor:
  - [X] server.el
  - [ ] squelch.el

blerh.
Need a ~debug~ after all maybe.
There's: ~debug-on-error~, ~init-file-debug~

what was this?
~output:interactive?~
[[file:source/core/packages/namespaced/emacs/squelch.el::output:interactive?)][here]]

refactor:
  - [X] server.el
  - [X] squelch.el

move to output/
  - k


** ├DONE───┤ ns/emacs/system
CLOSED: [2025-11-12 Wed 21:46]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-12 Wed 21:46]
- State "├CURRENT┤"  from              [2025-11-12 Wed 21:36]
:END:

contains:
  - secret
  - multiplexer

Neither of these is really a ~namespaced~ thing tho, right?

stuff them into user/_todo and be done.


** ├DONE───┤ refactor: elisp/dlv/
CLOSED: [2025-11-17 Mon 15:40]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-17 Mon 15:40]
- State "├CURRENT┤"  from              [2025-11-12 Wed 21:47]
:END:

see
  - [[file:source/core/packages/namespaced/elisp/dlv/init.el][here]]
  - uncomment: [[file:source/core/packages/namespaced/elisp/init.el::;; (imp ./dlv/init)][here]]

mmmh.......
Is this really elisp though?
Maybe it should just be ~namespaced/dlv~?
  - yeah...
  - [X] k

refactor shit....

[[file:source/core/packages/namespaced/dlv/init.el::TODO TODO HERE][u r here]]

* ├DONE───┤ pkg: undo-tree
CLOSED: [2025-11-17 Mon 16:02]
:LOGBOOK:
- State "├DONE───┤"  from              [2025-11-17 Mon 16:02]
:END:

add undo-tree
get config from 004:
  - file:../2023-07-23_sn004/mantle/config/undo-tree.el


* ├DONE───┤ init: break stuff off into files & imp them
CLOSED: [2025-11-17 Mon 17:47]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-17 Mon 17:47]
- State "├CURRENT┤"  from              [2025-11-17 Mon 16:21]
:END:

* ├DONE───┤ pkg: hydra
CLOSED: [2025-11-17 Mon 22:55]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-17 Mon 22:55]
- State "├CURRENT┤"  from              [2025-11-17 Mon 21:51]
:END:

get config from 004:
  - file:../2023-07-23_sn004/mantle/config/hydra/init.el

load user/art/init.el in init
  - or just user/art/box.el?

* ├DONE───┤ csharp sans treesit?
CLOSED: [2025-11-18 Tue 16:47]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-18 Tue 16:47]
- State "├CURRENT┤"  from              [2025-11-18 Tue 16:20]
:END:

pull config for csharp from sn004
file:../2023-07-23_sn004/mantle/config/dev-env/languages/csharp.el

(package-installed-p 'csharp-mode)
(package-installed-p 'csproj-mode)



* ├DONE───┤ org mode & theme tweaks
CLOSED: [2025-11-18 Tue 22:04]
:LOGBOOK:
- State "├DONE───┤"  from "├CURRENT┤"  [2025-11-18 Tue 22:04]
- State "├CURRENT┤"  from              [2025-11-18 Tue 22:02]
:END:

Where are my org tweaks for color of TODO/headline?
They aint working.
There's supposed to be purples and grays and shit

#+begin_src elisp
(pp-to-string imp-features)
#+end_src

#+RESULTS:
#+begin_example
((art (box)) (secret.d) (namespaced) (emacs-server) (system nil (os))
 (path nil (+uniquify) (buffer) (git) (regex) (dir) (files) (path))
 (theme nil (face))
 (str nil (+case-hydra) (case) (hash) (random) (propertize) (string) (buffer)
      (regex) (normalize))
 (dlv nil (display) (dlv) (class) (path) (debug)) (output nil (squelch))
 (package nil (upgrade (command) (mode))) (window nil (window))
 (unit nil (units)) (list)
 (alist nil (generic) (type (string) (keyword) (default) (types)) (internal))
 (datetime nil (timestamp) (format) (datetime)) (color)
 (buffer nil (yank) (search) (line) (point) (name) (manage) (eval) (type)
         (narrow) (region) (delete))
 (elisp nil (utils (test) (predicates)) (functions) (types))
 (user (mode (hydra (init)) (org nil (link) (keyword)))
       (config (hydra) (ai) (languages (csharp) (elisp) (common))
               (org (theme (zenburn)) nil (mode)) (files) (whitespace)
               (undo-tree) (help) (snippets) (completion)
               (theme (zenburn (whitespace)))
               (emacs nil (keybinds) (no-littering) (package))))
 (imp nil (package) (require) (load) (provide)))
#+end_example

#+begin_src elisp
(pp-to-string features)
#+end_src

#+RESULTS:
#+begin_example
(user:/config/languages/csharp sln-mode-autoloads package-vc csproj-mode
                               csproj-mode-autoloads let-alist sharper-autoloads
                               yaml-mode pulse gptel-curl gptel-org gptel
                               gptel-openai dired-aux helpful cc-langs cc-vars
                               cc-defs trace edebug info-look f elisp-refs
                               cl-print debug backtrace art/box
                               user:/config/hydra user:/mode/hydra/init
                               major-mode-hydra pretty-hydra
                               major-mode-hydra-autoloads pretty-hydra-autoloads
                               hydra lv hydra-autoloads lv-autoloads
                               loaddefs-gen lisp-mnt tar-mode arc-mode
                               archive-mode mm-archive network-stream url-cache
                               url-http url-auth url-gw nsm vc-hg vc-bzr vc-src
                               vc-sccs vc-svn vc-cvs vc-rcs log-view vc
                               bug-reference magit-extras face-remap help-fns
                               radix-tree misearch multi-isearch org-indent
                               oc-basic ol-eww eww url-queue mm-url ol-rmail
                               ol-mhe ol-irc ol-info ol-gnus nnselect gnus-art
                               mm-uu mml2015 mm-view mml-smime smime gnutls dig
                               gnus-sum shr pixel-fill kinsoku url-file svg dom
                               gnus-group gnus-undo gnus-start gnus-dbus dbus
                               xml gnus-cloud nnimap nnmail mail-source utf7
                               nnoo parse-time gnus-spec gnus-int gnus-range
                               gnus-win gnus nnheader ol-docview doc-view
                               image-mode exif ol-bibtex bibtex iso8601 ol-bbdb
                               ol-w3m ol-doi org-link-doi
                               user:/config/org/theme/zenburn ox-gfm ox-md
                               ox-odt rng-loc rng-uri rng-parse rng-match rng-dt
                               rng-util rng-pttrn nxml-parse nxml-ns nxml-enc
                               xmltok nxml-util ox-latex ox-icalendar org-agenda
                               ox-html table ox-ascii ox-publish ox org-attach
                               ob-shell embark-org org-element org-persist xdg
                               org-id org-refile org-element-ast inline avl-tree
                               generator org ob ob-tangle ob-ref ob-lob ob-table
                               ob-exp org-macro org-src sh-script smie treesit
                               executable ob-comint org-pcomplete org-list
                               org-footnote org-faces org-entities ob-emacs-lisp
                               ob-core ob-eval org-cycle org-table ol org-fold
                               org-fold-core org-keys oc org-loaddefs find-func
                               cal-menu calendar cal-loaddefs org-version
                               org-compat org-macs vc-git vc-dispatcher
                               jka-compr vertico-sort mule-util embark-consult
                               consult magit-bookmark bookmark compile
                               rainbow-delimiters highlight-quoted cus-start
                               terraform-mode noutline outline hcl-mode
                               user:/config/ai magit-submodule magit-blame
                               magit-stash magit-reflog magit-bisect magit-push
                               magit-pull magit-fetch magit-clone magit-remote
                               magit-commit magit-sequence magit-notes
                               magit-worktree magit-tag magit-merge magit-branch
                               magit-reset magit-files magit-refs magit-status
                               magit magit-repos magit-apply magit-wip magit-log
                               magit-diff smerge-mode diff-mode track-changes
                               git-commit log-edit message sendmail yank-media
                               puny rfc822 mml mml-sec epa epg rfc6068
                               epg-config gnus-util text-property-search
                               mm-decode mm-bodies mm-encode mail-parse rfc2231
                               rfc2047 rfc2045 mm-util ietf-drums mail-prsvr
                               mailabbrev mail-utils gmm-utils mailheader
                               pcvs-util add-log magit-core magit-autorevert
                               magit-margin magit-transient magit-process
                               with-editor shell pcomplete comint ansi-osc
                               magit-mode transient benchmark magit-git
                               magit-base magit-section format-spec
                               cursor-sensor crm llama
                               user:/config/languages/elisp elisp-demos
                               macrostep ring user:/config/languages/common
                               which-func imenu user:/config/org
                               user:/config/org/mode user:/mode/org
                               user:/mode/org/link user:/mode/org/keyword
                               user:/config/files deadgrep spinner dash s
                               recentf tree-widget time-stamp
                               user:/config/whitespace disp-table whitespace
                               ws-butler user:/config/undo-tree undo-tree diff
                               queue user:/config/help which-key
                               user:/config/emacs minions ansi-color comp
                               comp-cstr warnings comp-run comp-common profiler
                               display-line-numbers autorevert filenotify
                               user:/config/snippets yasnippet
                               user:/config/completion dabbrev cape corfu embark
                               ffap thingatpt edmacro kmacro orderless
                               marginalia savehist vertico secret.d
                               colorful-mode user:/config/emacs/keybinds
                               user:/config/theme/zenburn zenburn-theme
                               user:/config/emacs/no-littering no-littering
                               compat namespaced emacs-server server system
                               system:/os path path:/+uniquify path:/buffer
                               project dired dired-loaddefs path:/git
                               path:/regex path:/dir path:/files path:/path
                               theme theme:/face str str:/+case-hydra str:/case
                               str:/hash str:/random str:/propertize str:/string
                               str:/buffer str:/regex str:/normalize dlv
                               dlv:/display dlv:/dlv dlv:/class dlv:/path
                               dlv:/debug output output:/squelch
                               package:/upgrade/command package:/upgrade/mode
                               window:/window unit unit:/units list alist
                               alist:/type/string alist:/type/keyword
                               alist:/type/default alist:/generic
                               alist:/type/types alist:/internal datetime
                               datetime:/timestamp datetime:/format
                               datetime:/datetime color buffer buffer:/yank
                               buffer:/search buffer:/line buffer:/point
                               buffer:/name buffer:/manage buffer:/eval
                               buffer:/type buffer:/narrow buffer:/region
                               buffer:/delete elisp elisp:/utils/test
                               elisp:/utils/predicates elisp:/functions
                               elisp:/types time-date user:/config/emacs/package
                               use-package use-package-delight
                               use-package-bind-key bind-key easy-mmode
                               finder-inf cl-extra help-mode use-package-ensure
                               use-package-diminish use-package-core imp
                               imp:/package imp:/require imp:/load imp:/provide
                               derived range rx cus-edit pp cus-load wid-edit
                               cape-autoloads colorful-mode-autoloads
                               corfu-autoloads deadgrep-autoloads
                               elisp-demos-autoloads embark-consult-autoloads
                               consult-autoloads embark-autoloads
                               git-gutter-fringe-autoloads
                               fringe-helper-autoloads git-gutter-autoloads
                               git-modes-autoloads gptel-autoloads
                               hc-zenburn-theme-autoloads helpful-autoloads
                               elisp-refs-autoloads f-autoloads
                               highlight-quoted-autoloads hurl-mode-autoloads
                               macrostep-autoloads magit-autoloads pcase
                               magit-section-autoloads llama-autoloads
                               marginalia-autoloads minions-autoloads
                               no-littering-autoloads orderless-autoloads
                               ox-gfm-autoloads rainbow-delimiters-autoloads
                               s-autoloads spinner-autoloads
                               terraform-mode-autoloads dash-autoloads
                               hcl-mode-autoloads transient-autoloads
                               undo-tree-autoloads queue-autoloads
                               vertico-autoloads info with-editor-autoloads
                               ws-butler-autoloads yaml-mode-autoloads
                               yasnippet-autoloads zenburn-theme-autoloads
                               package browse-url url url-proxy url-privacy
                               url-expand url-methods url-history url-cookie
                               generate-lisp-file url-domsuf url-util mailcap
                               url-handlers url-parse auth-source cl-seq eieio
                               eieio-core cl-macs icons password-cache json
                               subr-x map byte-opt gv bytecomp byte-compile
                               url-vars cl-loaddefs cl-lib rmc iso-transl
                               tooltip cconv eldoc paren electric uniquify
                               ediff-hook vc-hooks lisp-float-type elisp-mode
                               mwheel term/x-win x-win term/common-win x-dnd
                               touch-screen tool-bar dnd fontset image
                               regexp-opt fringe tabulated-list replace
                               newcomment text-mode lisp-mode prog-mode register
                               page tab-bar menu-bar rfn-eshadow isearch
                               easymenu timer select scroll-bar mouse jit-lock
                               font-lock syntax font-core term/tty-colors frame
                               minibuffer nadvice seq simple cl-generic
                               indonesian philippine cham georgian utf-8-lang
                               misc-lang vietnamese tibetan thai tai-viet lao
                               korean japanese eucjp-ms cp51932 hebrew greek
                               romanian slovak czech european ethiopic indian
                               cyrillic chinese composite emoji-zwj charscript
                               charprop case-table epa-hook jka-cmpr-hook help
                               abbrev obarray oclosure cl-preloaded button
                               loaddefs theme-loaddefs faces cus-face macroexp
                               files window text-properties overlay sha1 md5
                               base64 format env code-pages mule custom widget
                               keymap hashtable-print-readable backquote threads
                               dbusbind inotify lcms2 dynamic-setting
                               system-font-setting font-render-setting cairo gtk
                               x-toolkit xinput2 x multi-tty move-toolbar
                               make-network-process native-compile emacs)
#+end_example

bug:
#+begin_src elisp
(theme:face:set! 'zenburn
  (zenburn-with-color-variables
    ;;---
    ;; Done states - little less dark.
    ;;---
    `(org-done                     :foreground ,zenburn-green-3)
    ...
#+end_src

fix:
#+begin_src elisp
(zenburn-with-color-variables
  (theme:face:set! 'zenburn
    ;;---
    ;; Done states - little less dark.
    ;;---
    `(org-done                     :foreground ,zenburn-green-3)
    ...
#+end_src


* -- U R HERE --
<<here>>

* pull latest in Win10VM
* org: inline quote & code tweaks

~code~
=quote=

Do:
  - Remove underline.
  - Make them different colors.
  - Maybe not quite so bright?
    - imitate Slack?
      - burnt orange sorta color
      - lighter background (already have this for code; quote is darker tho)

* ├CURRENT┤ source/_todo/multiplexer
:LOGBOOK:
- State "├CURRENT┤"  from              [2025-11-19 Wed 21:54]
:END:

delete or use

use?

╔════════╦════════════╦══════════════════════════════════════════════════════════════════════════════════════════════════════════╗
╠══TODO══╣            ║                                                                                                          ║
╠══TODO══╬══tomorrow══╣                                            ¡¡¡YOU ARE HERE!!!                                            ║
╠══TODO══╣            ║                                                                                                          ║
╚════════╩════════════╩══════════════════════════════════════════════════════════════════════════════════════════════════════════╝
refactor & simplify
  - multiplex.el
    - u r [[file:source/_todo/multiplexer/multiplex.el::;; TODO: HERE][here]]



* ├WAITING┤ source/_todo/secret
:LOGBOOK:
- State "├WAITING┤"  from              [2025-11-19 Wed 21:53] \\
  multiplexer first
:END:

delete or use?

oh. this requires ~multiplexer~

* LSP

Get language server stuff set up?


Grab LSP config from sn004

find todos:
#+begin_src elisp
;; TODO(lsp): uncomment:
#+end_src
  - [[file:source/user/config/languages/csharp.el::;; TODO(lsp): uncomment:][here]]

use Omnisharp for csharp.

* ├HOLDING┤ csharp & treesit?
:LOGBOOK:
- State "├HOLDING┤"  from "├CURRENT┤"  [2025-11-18 Tue 16:51]
- State "├CURRENT┤"  from              [2025-10-08 Wed 23:01]
:END:

~M-x treesit-install-language-grammar~

NO:   https://github.com/tree-sitter/csharp-tree-sitter
YES?: https://github.com/tree-sitter/tree-sitter-c-sharp

mmmh... yay. -_-
#+begin_quote
⛔ Warning (treesit): The installed language grammar for csharp cannot be located or has problems (symbol-error): /home/main/.config/emacs/tree-sitter/libtree-sitter-csharp.so: undefined symbol: tree_sitter_csharp
#+end_quote

#+begin_src elisp
(pp-to-string treesit-language-source-alist)
#+end_src

#+RESULTS:
: nil

oh... if I use "c-sharp" instead of "csharp" it will find the repo automatically?
nope.
Add a thing to ~treesit-language-source-alist~

#+begin_src elisp
(add-to-list 'treesit-language-source-alist '(c-sharp "https://github.com/tree-sitter/tree-sitter-c-sharp"))
#+end_src

#+begin_quote
⛔ Warning (treesit): The installed language grammar for c-sharp cannot be located or has problems (version-mismatch): 15
#+end_quote

hm... delete the .so first?
  - deleted both (=csharp= and =c-sharp=)

reinstall
~M-x treesit-install-language-grammar~

╔════════╦════════════╦══════════════════════════════════════════════════════════════════════════════════════════════════════════╗
╠══TODO══╣            ║                                                                                                          ║
╠══TODO══╬══tomorrow══╣                                            ¡¡¡YOU ARE HERE!!!                                            ║
╠══TODO══╣            ║                                                                                                          ║
╚════════╩════════════╩══════════════════════════════════════════════════════════════════════════════════════════════════════════╝
Maybe look at this first:
https://www.reddit.com/r/emacs/comments/1gjhe5a/is_developing_c_in_emacs_viable_without_obsolete/


Maybe try ~tree-sitter-langs~ package instead of manual?
https://github.com/emacs-tree-sitter/tree-sitter-langs

#+begin_src elisp
;; TODO(csharp): switch to `csharp-ts-mode'.
#+end_src
  - [[file:source/user/config/languages/csharp.el::;; TODO(csharp): switch to `csharp-ts-mode'.][here]]

TODO: make csharp config file
TODO: put ~treesit-language-source-alist~ recipe in config file?

* submit whitespace+ws-butler bug to Emacs

M-x report-bug or something

* repo buffernames

TODO groot or w/e for Project Rooted File Buffer Names (PRooFBuN)

* TRAMP into Win10 VM

I probably need an ssh server running or something.

I think Windows comes with OpenSSH now?
  - Does it come with server?
  - Else what should I use for the server?
    - Putty?

* org-babel no confirm

write a func that ~org-confirm-babel-evaluate~ can use to decide
whether to prompt with ~y-or-n-p~

by source type (major-mode)?

* eval after

Find ~(when (imp-feature?~
example
  - [[file:source/user/config/help.el::;; TODO: change to eval-after:][here]]

Fix to eval after said feature.



* imp-provide helper?

turn this:
#+begin_src elisp
(imp-provide user (imp-path-relative 'user (imp-path-sans-extension (imp-path-current-file))))
#+end_src

into a func
  - ~imp-provide-this~?

#+begin_src elisp
(imp-provide-this user)
#+end_src


* imp statistics

fix stuff

#+begin_src imp-timing
loading namespaced...
├─loading \./elisp/init...
│ ├─loading elisp...
│ │ ├─loading \./types...
│ │ │ └─00.0009 seconds
│ │ ├─loading \./functions...
│ │ │ └─00.0011 seconds
│ │ ├─loading \./predicates...
│ │ │ └─00.0007 seconds
│ │ ├─loading \./test...
│ │ │ └─00.0007 seconds
│ │ └─00.0039 seconds
│ └─00.0080 seconds
├─loading \./buffer/init...
│ ├─loading buffer...
│ │ ├─loading buffer:/delete...
│ │ │ └─00.0007 seconds
│ │ ├─loading buffer:/region...
│ │ │ └─00.0009 seconds
│ │ ├─loading buffer:/narrow...
│ │ │ └─00.0006 seconds
│ │ ├─loading buffer:/type...
│ │ │ └─00.0012 seconds
│ │ ├─loading buffer:/eval...
│ │ │ └─00.0006 seconds
│ │ ├─loading buffer:/manage...
│ │ │ └─00.0010 seconds
│ │ ├─loading buffer:/name...
│ │ │ └─00.0007 seconds
│ │ ├─loading buffer:/point...
│ │ │ └─00.0006 seconds
│ │ ├─loading buffer:/line...
│ │ │ └─00.0010 seconds
│ │ ├─loading buffer:/search...
│ │ │ └─00.0009 seconds
│ │ ├─loading buffer:/yank...
│ │ │ └─00.0007 seconds
│ │ └─00.0100 seconds
│ └─00.0119 seconds
├─loading \./unit/init...
│ ├─loading unit...
│ │ ├─loading unit:/units...
│ │ │ └─00.0009 seconds
│ │ └─00.0012 seconds
│ └─00.0044 seconds
├─loading \./datetime/init...
│ ├─loading datetime...
│ │ ├─loading \./datetime...
│ │ │ └─00.0014 seconds
│ │ ├─loading \./format...
│ │ │ └─00.0014 seconds
│ │ ├─loading \./timestamp...
│ │ │ └─00.0010 seconds
│ │ └─00.0043 seconds
│ └─00.0083 seconds
├─loading \./str/init...
#+end_src

** dedup
#+begin_quote
├─loading \./elisp/init...
│ ├─loading elisp...
#+end_quote

dedup. Should just be:
#+begin_quote
├─loading elisp...
#+end_quote

** root & children

#+begin_quote
│ ├─loading elisp...
│ │ ├─loading \./types...
#+end_quote

maybe should be?
#+begin_quote
│ ├─loading elisp...
│ │ ├─loading elisp:/types...
#+end_quote

maybe this is:
"Find canonical feature name from provided"

* namespaced/list/plist

Start the ~plist~ lib with some of [[file:/usr/share/emacs/30.2/lisp/org/org-macs.el.gz][org plist funcs]]

~mux~ has plist delete: ~_mux-plist-delete~


* namespace again
** Namespace everything to 'ns'?

ns/emacs/server?
ns/string/split?

** rename str to string?

so that they show up with the string functions?

** use window

want my ~window:kill-or-quit~
  - for ~helpful~: [[file:source/user/config/help.el::;; TODO: needs namespaced:window lib][here]]
  - and ~deadgrep~ maybe?

** slash instead of colon?

Slash seems like maybe a better separator?

** ns/debug.el

There's: ~debug-on-error~, ~init-file-debug~

make file
move func to it from [[file:source/core/packages/namespaced/emacs/squelch.el::;; TODO(debug): move this to debug.el?][here]]

** path - update/add funcs from imp/path.el

wait til they're all settled though?
  - [[*imp/path: move imp :path normalizers to path.el][imp/path: move imp :path normalizers to path.el]]

** defgroups - no "group" in name

deadgrep for it inside the ~namespaced~ dir.

** buffer:/line remaps

[[file:source/core/packages/namespaced/buffer/line.el::;; (use-package emacs][line.el]]

#+begin_src elisp
;; (use-package emacs
;;
;;   ;;------------------------------
;;   :bind ; emacs
;;   ;;------------------------------
;;
;;   ;; Remap C-a to `buffer:cmd:line/smart:move-beginning/logical'
;;   (([remap move-beginning-of-line] . buffer:cmd:line/smart:move-beginning/logical)
;;
;;    ;; Remap C-a to `buffer:cmd:line/smart:move-beginning/visual' in visual-line-mode-map
;;    :map visual-line-mode-map
;;    ([remap beginning-of-visual-line] . buffer:cmd:line/smart:move-beginning/visual)
;;    ([remap move-beginning-of-line]   . buffer:cmd:line/smart:move-beginning/visual)
;;    ([remap end-of-visual-line]       . buffer:cmd:line/smart:move-end/visual)
;;    ([remap move-end-of-line]         . buffer:cmd:line/smart:move-end/visual)))
#+end_src

put that in my init

** private vars

deadgrep for "int<" in namespaced dir.
replace all ~int<NAME>:...~ with ~_:$NAME:...~

* source/core/packages/_todo

has:
  - signature
    - want
  - taskspace
    - want
  - template
    - hmmm....


* my public IP(s)

is there a package that will figure out my IP for me?

else just make a call to the one that I used for the bash prompt

* auth-source / 1pass

what dis? ~gptel~ uses it by default to find API key.

Can I hook in 1pass?
  - probably, but pkg isn't very used.
https://melpa.org/#/auth-source-1password

* imp-provide & native compilation

This is in *Async-native-compile-log* buffer after emacs init:
#+begin_quote
Compiling /home/main/.config/emacs/source/core/packages/imp/provide.el...

In end of data:
provide.el: Warning: the function ‘imp--feature-add’ is not known to be defined.
provide.el: Warning: the function ‘imp--error’ is not known to be defined.
provide.el: Warning: the function ‘imp-feature-normalize’ is not known to be defined.
Compilation finished.
#+end_quote

How to fix?
  - Do I need to ~require~ all the predecessor files?

Go look at ~use-package~ core's compile stuff?
Maybe some of those things are relevant?

* imp-features weirdness

wtf is imp doing?
#+begin_src elisp
(pp-to-string imp-features)
#+end_src

#+RESULTS:
: ((namespaced) (theme nil (face)) (str nil (normalize))
:  (datetime nil (timestamp) (format) (datetime)) (unit nil (units))
:  (buffer nil (region) (delete)) (elisp nil (functions) (types))
:  (imp nil nil nil nil nil (package) (require) (load) (provide) (parser)))

#+begin_quote
(imp nil nil nil nil nil (package) (require) (load) (provide) (parser))
#+end_quote


* imp/timing: let exceptions bubble up

Do whatever `imp` does for that.

I think the macro returns code so that when the code runs
there isn't a macro in the way.

o* imp/path: move imp :path normalizers to path.el

Integrate them into eg `imp-path` function.

Rename ~imp-path-root-set~ to...
  - ~imp-root~?
  - ~imp-root-set~?

* imp unit tests?

What all does ~use-package~ do for its tests?

* use-package-editor

I wanna be able to eval a ~use-package~ custom var.

#+begin_src elisp
    ;;------------------------------
    :custom
    ;;------------------------------

    ;; (setq gptel-model 'gpt-5)
    (gptel-model 'gpt-4o)
#+end_src

I wanna be able to put the cusor after ~(gptel-model 'gpt-4o)~ and ~eval-last-sexp~.
Instead of having to add ~setq~ (or ideally ~customize-set-variable~) to the front.


* gptel: PrivateGPT

gptel can support PrivateGPT
  - see [[file:~/.config/emacs/elpa/gptel-20250818.648/gptel.el::;; - For PrivateGPT: define a backend with `gptel-make-privategpt', which see.][here]]

https://github.com/zylon-ai/private-gpt

Get that running on my work org notes?
* treesit: how can you do it in the init file?

prev treesits:
  - [[*fix: treesit & JSON][fix: treesit & JSON]]
  - [[*csharp & treesit?][csharp & treesit?]]

how to install grammers via elisp?
  - and how not to reinstall existing ones every time.

Is there some package already that helps?
  - like ~treesit-auto~ for Emacs 29
    - but I think that uses the ~tree-sitter~ package instead of the built in ~treesit~.

** do it in the init file for

...probably everything in the langs dir?
file:source/user/config/languages/
  - JSON


** decide between foo-ts and foo for org-src-lang-modes

[[file:source/user/config/org/mode.el::;; TODO: how to decide between `json' and `json-ts'?]]
#+begin_src elisp
  ;; TODO: how to decide between `json' and `json-ts'?
  ;; TODO: ...config var? `--/foo/bar/use-treesit'???
  (push '("json"                    . json-ts)    org-src-lang-modes)
#+end_src


* imp-provide default?

Make no-args ~imp-provide~ do something like:
  1. (imp-path-current-file)
  2. sans extension
  3. look for root (eg ~user-emacs-dir~)
     - choose root that provides shortest relative path.
  4. use relative path as provide args

eg in this file, these should be equivalent:
#+begin_src elisp
(imp-provide)
(imp-provide .emacs.d 42)
#+end_src


* imp: use Emacs' "subfeatures"?

#+begin_src elisp
(provide feature '(subfeature0 subfeature1 ...))
#+end_src

~require~ can't require subfeatures, so...
how do you _use_ subfeatures?
  - is it just ~(featurep feature subfeature3)~?

* imp output

Make ~imp--error~ and ~imp--debug~ not generate such a huge block of the stacktrace.

Use ~defsubst~ instead of ~defun~ for all the underlying funcs?

* imp statistics

Uncomment ~:stats~ stuff in imp-parser.
  - rg: TODO(stats): uncomment

Implement ~:stats~ keyword's values:
  - [ ] nil
  - [ ] t / defaults
  - [ ] timing
  - [ ] debug
  - [ ] autoshow

rg: =TODO(stats)=

Expand stats to more than just current timing.

Store stats in feature tree.

Make timing buffer show all stats.

Make `imp-timing' take stats flags so it can decide whether to time or not?
  - Make it just spit back body if timing flag not present (unless "always timing" custom is set).

Make timing buffer fill in as you go with `debug' flag or something.

Make timing buffer able to be generated after-the-fact via command.

Add ~:stats~ info to ~imp-parser~ docstr.
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]


* imp fixes

** imp-load keyword :debug

if debug flag, do this instead:

#+begin_src elisp
(pp-to-string
 (macroexpand-1
  '(imp-parser imp/init
     :path (imp-path-join user-emacs-directory
                          "path/to/imp"))))
#+end_src



** imp-parser keyword: ~:load-message~?

an option to disable the ~'nomessage~ param in call to ~load~
  - [[file:source/core/packages/imp/parser.el::'nomessage)))))][here]]

or maybe a ~:let~ / ~:lexical~?

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]


** imp-parser keyword: ~:load-suffixes~?

Modify ~load-suffixes~ for one thing's load.

and something for ~load-file-rep-suffixes~ as well?

Or just like a generic ~:vars~ or ~:custom~?

Add to ~imp-parser~ docstr
  - [[file:source/core/packages/imp/parser.el:::optional OPT Load NAME if it exists; do nothing if it does not.][here]]

* imp-load keyword: flag
Make it an eventual imp-load keyword?
#+begin_src elisp
(imp-load foo
          :flag -bar +baz)
#+end_src

Maybe =flag= is a bad name...
Maybe figure out a better?


* snippet: notes directive

Fix these warnings in *Messages* during init?
#+begin_src txt
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/header
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/pass
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/quote
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src-insert
Ignoring unknown directive "notes" in file: /home/main/.config/emacs/snippets/org-mode/src-yank
#+end_src


* snippet: /todo/penis

Make a snippet friendly TODO penis.
This one indents badly:

desired:/todo/penis
                             TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO.
TODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
ODO TODO TODO TODO TODO TODO TODO TODO TODO
 TODO TODO TODO TODO TODO TODO TODO TODO TODO
DO TODO TODO TODO TODO TODO TODO TODO TODO'
O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

actual:/todo/penis
                             TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO.
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             ODO TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO TODO TODO TODO TODO TODO TODO TODO
                             DO TODO TODO TODO TODO TODO TODO TODO TODO'
                             O TODO TODO TODO TODO TODO TODO TODO TODO
                             TODO TODO

* treesitter
* org

imp works* now.
Make org work now.

I wanna have a dir for it.
I wanna use imp. Debugging is a bit easier.
  - [[*imp][imp]]

Copy
  - from
    ~2023-07-23_sn004/mantle/config/org~
  - to
    ~2025-03-13_sn005/source/user/config/org~

Start editting for content:
  - [X] init.el
  - [X] mode.el
    - [X] [[*innit][you need some of innit]]
    - [X] [[file:source/user/config/org/theme/zenburn.el::;; TODO: Now I need some innit funcs...][you are here]]
    - [X] need org func lib thingy from sn004 too:
      - [X] [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/keyword.el][keyword.el]]
      - [X] [[file:~/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/link.el][link.el]]

And then...
  - [ ] journal.el
  - [ ] pretty.el
  - [ ] version-control.el

Skip/avoid for now?
  - [ ] agenda.el
  - [ ] contacts.el
  - [ ] toggl.el




* titlebar

* Secrets: 1Password CLI?

Is there a package for 1Password?
Should I use 1Password CLI instead of secret repo?

* imp improvements
** use-package integration via keyword

[[file:source/core/packages/imp/package.el::;; https://www.gnu.org/software/emacs/manual/html_node/use-package/Creating-an-extension.html][here]]

((use-package-ensure-elpa 'test-imp-up '(t) 'nil)
 (defvar use-package--warning10
   #'(lambda (keyword err)
       (let
           ((msg
             (format "%s/%s: %s" 'test-imp-up keyword
                     (error-message-string err))))
         (display-warning 'use-package msg :error))))
 (condition-case-unless-debug err
     (progn
       (condition-case-unless-debug err (message "init")
         (error (funcall use-package--warning10 :init err)))
       (if (not (require 'test-imp-up nil t))
           (display-warning 'use-package
                            (format "Cannot load %s" 'test-imp-up)
                            :error)
         (condition-case-unless-debug err (progn (message "config") t)
           (error (funcall use-package--warning10 :config err)))))
   (error (funcall use-package--warning10 :catch err))))


always imp?

from [[file:/usr/share/emacs/30.1/lisp/use-package/use-package-ensure.el.gz][use-package-ensure.el.gz]]
#begin_src emacs-lisp
(defcustom use-package-always-ensure nil
  "Treat every package as though it had specified using `:ensure SEXP'.
See also `use-package-defaults', which uses this value."
  :type 'sexp
  :group 'use-package-ensure
  :version "29.1")

(add-to-list 'use-package-defaults
             '(:ensure (list use-package-always-ensure)
                       (lambda (name args)
                         (and use-package-always-ensure
                              (not (plist-member args :load-path))))) t)
#end_src

(pp use-package-defaults)

use-package-defaults is alist of (keyword form-for-default-value form-for-whether-to-assign-default-value)

((:config '(t) t) (:init nil t)
 (:catch t (lambda (name args) (not use-package-expand-minimally)))
 (:defer use-package-always-defer
         (lambda (name args)
           (and use-package-always-defer
                (not (plist-member args :defer))
                (not (plist-member args :demand)))))
 (:demand use-package-always-demand
          (lambda (name args)
            (and use-package-always-demand
                 (not (plist-member args :defer))
                 (not (plist-member args :demand)))))
 (:ensure (list use-package-always-ensure)
          (lambda (name args)
            (and use-package-always-ensure
                 (not (plist-member args :load-path)))))
 (:pin use-package-always-pin use-package-always-pin))

** strip ~use-package~ down and make an argparser from it

;;------------------------------------------------------------------------------
;; Load Parsing Like Use-Package
;;------------------------------------------------------------------------------
;; `use-package' (macro)
;;   - `use-package-core' (macro)
;;     - `use-package-normalize-keywords'
;;       - `use-package-normalize-plist'
;;         - `use-package-normalize/:keyword'

;; (defun use-package-merge-keys (key new old)
;;   "Originally borrowed from `use-package-merge-keys'"
;;   (let ((merger (assq key use-package-merge-key-alist)))
;;     (if merger
;;         (funcall (cdr merger) new old)
;;       (append new old))))

;; (defun imp--load-normalize (name input &optional plist)
;;   "Given a pseudo-plist INPUT, normalize it to a regular plist.
;; The normalized key/value pairs from input are added to PLIST,
;; extending any keys already present.

;; Originally borrowed from `use-package-normalize-plist'"
;;   (if (null input)
;;       plist
;;     (let* ((keyword (car input))
;;            (xs (use-package-split-list #'keywordp (cdr input)))
;;            (args (car xs))
;;            (tail (cdr xs))
;;            (normalizer
;;             (intern-soft (concat "use-package-normalize/"
;;                                  (symbol-name keyword))))
;;            (arg (and (functionp normalizer)
;;                      (funcall normalizer name keyword args)))
;;            (error-string (format "Unrecognized keyword: %s" keyword)))
;;       (if (memq keyword use-package-keywords)
;;           (progn
;;             (setq plist (imp--load-normalize
;;                          name tail plist))
;;             (plist-put plist keyword
;;                        (if (plist-member plist keyword)
;;                            (funcall merge-function keyword arg
;;                                     (plist-get plist keyword))
;;                          arg)))
;;         (if use-package-ignore-unknown-keywords
;;             (progn
;;               (display-warning 'use-package error-string)
;;               (imp--load-normalize
;;                name tail plist))
;;           (use-package-error error-string))))))


** path: handle symlinks

e.g. in ~~/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/init.org~
(let ((path-from-user (imp-path-current-dir-relative :user)))
  (imp:load :feature  '(:user config org mode)
            :path     path-from-user ;; (imp:path:current:dir/relative :user)
            :filename "mode"))
gets error:
Debugger entered--Lisp error: (error "[ERROR--]: imp-path-current-dir-relative:
Current directory is not relative to FEATURE/BASE!
FEATURE/BASE: :user
  root path:    /home/main/.config/emacs/source/user/
  curr path:    /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/
---> result:    /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/source/user/config/org/")

It gets this because emacs loaded via symlink:
ll ~/.config/emacs
lrwxrwxrwx 1 main main 53 Mar 14 15:30 /home/main/.config/emacs -> /home/main/ocean/vault/.config/emacs/2025-03-13_sn005/

So it thinks those paths are different when actually they're the same after following the symlink.

** imp-path-root-set

*** no error msg on repeat calls

working on [[file:source/core/packages/namespaced/str/init.el][ns/str/init.el]] and calling `eval-buffer' to see if the errors are gone yet.

So this gets called each time:
(imp-path-root-set :str
                   (imp-path-current-dir)
                   (imp-file-current))

Don't want the _same exact_ call to trigger the error message:
  > apply: [ERROR--]: imp-path-root-set: FEATURE-BASE ’:str’ is already an imp root.

*** defaults

I do this a lot in init files:

(imp-path-root-set :str
                   (imp-path-current-dir)
                   (imp-file-current))

Make those the defaults?
(imp-path-root-set :str)

** imp-timing default file/path

90+% I just want current dir/file:

(imp-timing
    :elisp
    (imp-file-current)
    (imp-path:current:dir)
  ...)

Can I make them optional?
(imp-timing
    :elisp
  ...)

maybe like `dolist'?
(imp-timing (:elisp)  ...)
(imp-timing (:elisp ?path ?file)  ...)


Or split into two?

(imp-timing
    :elisp
  ...)

(imp-timing-also
    :elisp
    path
    file
  ...)

** imp-load default filename

Want to be able to just do this:

(imp-path-root-set :user
                   (imp-path-join user-emacs-directory 'source 'user))
(imp-load :feature '(:user config org))

instead of this:

(imp-path-root-set :user
                   (imp-path-join user-emacs-directory 'source 'user))
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'config 'org))

Can do just this I think?:
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'source 'user 'config 'org))

Want to be able to do like:
(imp-load :feature '(:user config org)
          :path (imp-path-join user-emacs-directory 'source 'user 'config 'org))
(imp-load :feature '(:user config foo))
(imp-load :feature '(:user config bar))
(imp-load :feature '(:user baz))
** ??? Add to places in imp/path.el

`convert-standard-filename' for canonicalizing filenames/fielpaths.
(expand-file-name (convert-standard-filename "etc/") user-emacs-directory)
  - https://github.com/emacscollective/no-littering/blob/ea15b1c607d4036ce37326bd5b4b2f4291ddfd60/no-littering.el#L92C3-L92C77

** ??? refactor funcs

imp--load-parse
  - make error checking funcs?
  - make bool flag parsing func

** ??? when I get to tests

https://emacs.stackexchange.com/a/17202


* zenburn: high contrast mode?

Can I make ~hc-zenburn~ piggyback on top of ~zenburn~?
  - Probably not... The colors are probably all hand-picked.
    - But ~hc-zenburn~ does have a script to mess with brightness.
      - https://github.com/edran/hc-zenburn-emacs/blob/master/change_brightness.py
    - And I have funcs to mess with colors:
      - [[file:source/core/packages/innit/face.el::defun innit:color:darken (color alpha &optional colors-alist][here]] or [[file:/home/main/ocean/vault/.config/emacs/2023-07-23_sn004/modules/mode/org/keyword.el][sn004]]

TODO: Make ~zenburn-high-contrast~ for ~zenburn~ somehow.



